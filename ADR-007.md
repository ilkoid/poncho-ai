# ADR-007: Refactoring `ReActCycle` Execution Model

## Status
**Proposed**

## Date
2026-01-13

## Decision Makers
- System Architect
- Senior Go Engineer (Framework Owner)

---

## Context

The `chain.ReActCycle` component implements a ReAct (Reasoning + Acting) loop and serves as the core execution engine of the framework.

The current implementation is production-ready and stable, but several architectural constraints limit future scalability and extensibility:

1. **Single-flight execution model**  
   `ReActCycle.Execute()` holds a global mutex for the entire duration of execution, including:
   - LLM inference latency,
   - tool execution,
   - streaming callbacks.

   As a result, a single `ReActCycle` instance can process only one request at a time.

2. **Mixed responsibilities**  
   `ReActCycle` currently acts as:
   - an execution orchestrator,
   - a runtime state container,
   - an event dispatcher,
   - a debug lifecycle coordinator.

   This creates pressure toward a God Object as new features are added.

3. **Underutilized Step abstraction**  
   Although a `Step` interface exists, the actual execution order is hard-coded (`LLM â†’ Tools`), preventing:
   - configuration-driven pipelines,
   - insertion of intermediate steps (reflection, validation, guardrails).

4. **Implicit control signaling**  
   Certain control flows (e.g., `UserChoiceRequest`) are implemented via string markers in the model output, which:
   - are not type-safe,
   - create hidden coupling between prompt logic and orchestration.

The system is expected to evolve toward:
- concurrent execution,
- richer execution graphs,
- stricter execution contracts,
- UI-driven interaction flows.

---

## Decision

We will refactor the `ReActCycle` architecture by **separating immutable configuration from execution-time state**, introducing a **dedicated execution object**, and formalizing control signaling and step orchestration.

The refactor will be executed incrementally and **will not break the public API** in the initial phases.

---

## Decision Details

### 1. Split Template and Execution State

Introduce two clearly separated concepts:

#### `ReActCycle` (Template)
- Immutable after construction.
- Holds:
  - configuration (`ReActCycleConfig`),
  - registries (models, tools),
  - default parameters.
- Thread-safe by immutability.

#### `ReActExecution` (Runtime)
- Created per `Execute()` invocation.
- Holds:
  - `ChainContext`,
  - step instances,
  - emitter, debug recorder,
  - execution timestamps and flags.
- Never shared across goroutines.

This removes the need for a global mutex across execution.

---

### 2. Remove Single-Flight Constraint

- Eliminate `sync.Mutex` guarding the entire `Execute()` lifecycle.
- Allow multiple concurrent executions from a single `ReActCycle` instance.
- Preserve correctness through execution-local state.

---

### 3. Introduce Typed Execution Signals

Replace implicit string-based control markers with a typed execution signaling model:

```go
type ExecutionSignal int

=====
Signals will explicitly represent:

final answer,

user input request,

error termination.

This decouples orchestration logic from prompt content.

4. Promote Step Abstraction to a Real Pipeline

Introduce a StepExecutor responsible for orchestrating steps.

Treat LLMInvocationStep and ToolExecutionStep as first-class pipeline steps.

Prepare the system for future steps without modifying ReActCycle.

5. Isolate Cross-Cutting Concerns via Observers

Introduce observer interfaces for:

debug recording,

event emission,

streaming callbacks.

Execution logic will no longer call emit/debug functions directly.

Consequences
Positive

Enables true concurrent execution.

Prevents architectural degradation as features grow.

Improves testability and reasoning about execution flow.

Allows future chain types without duplicating orchestration logic.

Strengthens execution contracts and UI integration.

Negative / Trade-offs

Increased number of abstractions.

Higher conceptual overhead for new contributors.

Requires careful migration to avoid subtle behavioral changes.

Alternatives Considered
1. Keep Single-Flight Model

Rejected
Limits scalability and forces users to instantiate multiple cycles manually.

2. Add RWMutex or Partial Locking

Rejected
Adds complexity without addressing responsibility coupling.

3. Rewrite Execution Engine from Scratch

Rejected
High risk, unnecessary given the solid existing foundation.

Migration Strategy

Introduce new execution model alongside existing code.

Migrate Execute() internals first.

Preserve public API and configuration semantics.

Add race tests and golden tests before removal of legacy paths.

Document new lifecycle clearly.

Validation Criteria

Multiple concurrent Run() calls execute correctly.

Event order remains stable.

Streaming semantics preserved.

Debug artifacts identical to baseline.

No data races under go test -race.
