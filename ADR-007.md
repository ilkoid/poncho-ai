# ADR-007: Refactoring `ReActCycle` Execution Model

## Status
**Implemented** (Phases 1-4 Complete, Phase 5 In Progress)

## Date
2026-01-13 (Created)
2026-01-13 (Implemented)

## Decision Makers
- System Architect
- Senior Go Engineer (Framework Owner)

---

## Context

The `chain.ReActCycle` component implements a ReAct (Reasoning + Acting) loop and serves as the core execution engine of the framework.

The current implementation is production-ready and stable, but several architectural constraints limited future scalability and extensibility:

1. **Single-flight execution model**
   `ReActCycle.Execute()` held a global mutex for the entire duration of execution, including:
   - LLM inference latency,
   - tool execution,
   - streaming callbacks.

   As a result, a single `ReActCycle` instance could process only one request at a time.

2. **Mixed responsibilities**
   `ReActCycle` acted as:
   - an execution orchestrator,
   - a runtime state container,
   - an event dispatcher,
   - a debug lifecycle coordinator.

   This created pressure toward a God Object as new features were added.

3. **Underutilized Step abstraction**
   Although a `Step` interface existed, the actual execution order was hard-coded (`LLM â†’ Tools`), preventing:
   - configuration-driven pipelines,
   - insertion of intermediate steps (reflection, validation, guardrails).

4. **Implicit control signaling**
   Certain control flows (e.g., `UserChoiceRequest`) were implemented via string markers in the model output, which:
   - were not type-safe,
   - created hidden coupling between prompt logic and orchestration.

The system was expected to evolve toward:
- concurrent execution,
- richer execution graphs,
- stricter execution contracts,
- UI-driven interaction flows.

---

## Decision

We refactored the `ReActCycle` architecture by **separating immutable configuration from execution-time state**, introducing a **dedicated execution object**, formalizing **control signaling** and **step orchestration**, and **isolating cross-cutting concerns via observers**.

The refactor was executed incrementally across 5 phases and **did not break the public API**.

---

## Decision Details

### Phase 1: Split Template and Execution State (COMPLETED)

Introduced two clearly separated concepts:

#### `ReActCycle` (Template)
- Immutable after construction (except runtime defaults via mutex).
- Holds:
  - configuration (`ReActCycleConfig`),
  - registries (models, tools),
  - step templates (LLMInvocationStep, ToolExecutionStep),
  - default parameters (via mutex-protected config).
- Thread-safe by immutability of core fields.

#### `ReActExecution` (Runtime)
- Created per `Execute()` invocation.
- Holds:
  - `ChainContext`,
  - step instances (cloned from templates),
  - emitter, debug recorder,
  - execution timestamps and flags.
- Never shared across goroutines.

This removed the need for a global mutex across execution.

**Files Modified:**
- `pkg/chain/execution.go` (NEW): ReActExecution as pure data container
- `pkg/chain/react.go`: Removed `sync.Mutex`, updated Execute()

---

### Phase 2: Typed Execution Signals (COMPLETED)

Replaced implicit string-based control markers with a typed execution signaling model:

```go
type ExecutionSignal int

const (
    SignalNone ExecutionSignal = iota
    SignalFinalAnswer
    SignalNeedUserInput
    SignalError
)

type StepResult struct {
    Action NextAction
    Signal ExecutionSignal
    Error  error
}
```

Signals now explicitly represent:
- final answer,
- user input request,
- error termination.

This decouples orchestration logic from prompt content.

**Files Modified:**
- `pkg/chain/step.go`: Added ExecutionSignal, StepResult

---

### Phase 3: Real Step Pipeline (COMPLETED)

Introduced `StepExecutor` interface and `ReActExecutor` implementation:

```go
type StepExecutor interface {
    Execute(ctx context.Context, exec *ReActExecution) (ChainOutput, error)
}

type ReActExecutor struct {
    observers []ExecutionObserver
}
```

LLMInvocationStep and ToolExecutionStep are now first-class pipeline steps.

The system is ready for future steps (Reflection, Validation, Memory) without modifying ReActCycle.

**Files Modified:**
- `pkg/chain/executor.go` (NEW): StepExecutor interface, ReActExecutor
- `pkg/chain/executor_test.go` (NEW): Tests for executor pattern
- `pkg/chain/react.go`: Updated to use StepExecutor

---

### Phase 4: Isolate Cross-Cutting Concerns via Observers (COMPLETED)

Introduced observer interfaces for cross-cutting concerns:

```go
type ExecutionObserver interface {
    OnStart(ctx context.Context, exec *ReActExecution)
    OnIterationStart(iteration int)
    OnIterationEnd(iteration int)
    OnFinish(result ChainOutput, err error)
}
```

**Observer Implementations:**

1. **ChainDebugRecorder** - Implements ExecutionObserver for debug logging
   - Handles Start/StartIteration/EndIteration/Finalize lifecycle
   - No longer called directly from executor

2. **EmitterObserver** - Sends final events (EventDone, EventError)
   - Separates event emission from core orchestration

3. **EmitterIterationObserver** - Sends iteration events
   - EventThinking, EventToolCall, EventToolResult, EventMessage
   - Allows fine-grained event control

Execution logic no longer calls emit/debug functions directly.

**Files Modified:**
- `pkg/chain/debug.go`: ChainDebugRecorder implements ExecutionObserver
- `pkg/chain/observers.go` (NEW): EmitterObserver, EmitterIterationObserver
- `pkg/chain/executor.go`: Added observer registration, removed direct Emit/debug calls
- `pkg/chain/react.go`: Registers observers with executor
- `pkg/chain/executor_test.go`: Added tests for observers

---

### Phase 5: Documentation and Architecture Contracts (IN PROGRESS)

Creating comprehensive documentation:
- ADR completion and update
- Godoc for lifecycle and architecture
- Architecture diagrams

---

## Consequences

### Positive

âœ… **Enables true concurrent execution** - Multiple Execute() calls can run simultaneously
âœ… **Prevents architectural degradation** - Clear separation of concerns
âœ… **Improves testability** - Each component can be tested in isolation
âœ… **Allows future chain types** - New executors can be added without modifying ReActCycle
âœ… **Strengthens execution contracts** - Typed signals and observer pattern
âœ… **Better observability** - Clean separation of debug/events from core logic

### Negative / Trade-offs

âš ï¸ **Increased number of abstractions** - More types to understand
âš ï¸ **Higher conceptual overhead** - New contributors need to learn template vs execution distinction
âš ï¸ **Migration complexity** - Required careful implementation to avoid behavioral changes

---

## Alternatives Considered

### 1. Keep Single-Flight Model
**Rejected** - Limits scalability and forces users to instantiate multiple cycles manually.

### 2. Add RWMutex or Partial Locking
**Rejected** - Adds complexity without addressing responsibility coupling.

### 3. Rewrite Execution Engine from Scratch
**Rejected** - High risk, unnecessary given the solid existing foundation.

---

## Migration Strategy

**COMPLETED:**
1. âœ… Introduced new execution model (Phases 1-2)
2. âœ… Migrated Execute() internals (Phases 3-4)
3. âœ… Preserved public API and configuration semantics
4. âœ… Added comprehensive tests with race detector
5. ğŸ”„ Documenting new lifecycle (Phase 5 - In Progress)

---

## Validation Criteria

**All Met:**
- âœ… Multiple concurrent Run() calls execute correctly
- âœ… Event order remains stable
- âœ… Streaming semantics preserved
- âœ… All tests pass with `go test -race`
- âœ… No data races detected
- âœ… Public API unchanged

---

## Architecture Overview

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                         ReActCycle                               â”‚
â”‚  (Immutable Template - created once, shared across requests)    â”‚
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Model       â”‚  â”‚ Tools        â”‚  â”‚ ReActCycleConfig     â”‚   â”‚
â”‚  â”‚ Registry    â”‚  â”‚ Registry     â”‚  â”‚ - MaxIterations      â”‚   â”‚
â”‚  â”‚             â”‚  â”‚              â”‚  â”‚ - SystemPrompt       â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ - PromptsDir         â”‚   â”‚
â”‚                                        â”‚ - DefaultEmitter     â”‚   â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” - DefaultDebugRec    â”‚   â”‚
â”‚  â”‚ Step Templates                     â”‚ - StreamingEnabled   â”‚   â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚ (runtime defaults)   â”‚   â”‚
â”‚  â”‚ â”‚ LLMInvocation    â”‚               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”‚ â”‚ Step Template     â”‚                                          â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚ Runtime (protected)  â”‚   â”‚
â”‚  â”‚ â”‚ ToolExecution    â”‚               â”‚ by mutex for writes  â”‚   â”‚
â”‚  â”‚ â”‚ Step Template    â”‚               â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                                          â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜                          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â”‚ Execute() [Thread-safe, concurrent]
                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                      ReActExecution                              â”‚
â”‚  (Runtime State - created per Execute(), never shared)          â”‚
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ ChainContext â”‚  â”‚ Step        â”‚  â”‚ Cross-cutting        â”‚   â”‚
â”‚  â”‚              â”‚  â”‚ Instances   â”‚  â”‚ Concerns            â”‚   â”‚
â”‚  â”‚ - Messages   â”‚  â”‚ (cloned)    â”‚  â”‚                      â”‚   â”‚
â”‚  â”‚ - Input      â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â”‚ - Emitter           â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ â”‚ LLMStep â”‚ â”‚  â”‚ - DebugRecorder     â”‚   â”‚
â”‚                    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”‚ - StreamingEnabled  â”‚   â”‚
â”‚                    â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                    â”‚ â”‚ToolStep â”‚ â”‚                              â”‚
â”‚                    â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚                    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚ Execution Metadata   â”‚   â”‚
â”‚                                      â”‚ - Config (ref)       â”‚   â”‚
â”‚                                      â”‚ - FinalSignal        â”‚   â”‚
â”‚                                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â”‚ Passed to
                            â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                       ReActExecutor                               â”‚
â”‚  (StepExecutor - executes iteration loop)                        â”‚
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ Observer List                                             â”‚   â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”               â”‚   â”‚
â”‚  â”‚ â”‚ ChainDebug       â”‚  â”‚ EmitterObserver â”‚               â”‚   â”‚
â”‚  â”‚ â”‚ Recorder         â”‚  â”‚                 â”‚               â”‚   â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜               â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ IterationObserver (separate)                              â”‚   â”‚
â”‚  â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”      â”‚   â”‚
â”‚  â”‚ â”‚ EmitterIterationObserver                          â”‚      â”‚   â”‚
â”‚  â”‚ â”‚ - EmitThinking()                                  â”‚      â”‚   â”‚
â”‚  â”‚ â”‚ - EmitToolCall()                                  â”‚      â”‚   â”‚
â”‚  â”‚ â”‚ - EmitToolResult()                                â”‚      â”‚   â”‚
â”‚  â”‚ â”‚ - EmitMessage()                                   â”‚      â”‚   â”‚
â”‚  â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜      â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                                  â”‚
â”‚  Execute(exec *ReActExecution):                                  â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”‚
â”‚  â”‚ 1. Notify observers: OnStart                            â”‚    â”‚
â”‚  â”‚ 2. Append user message to history                       â”‚    â”‚
â”‚  â”‚ 3. For each iteration:                                  â”‚    â”‚
â”‚  â”‚    a. Notify: OnIterationStart                          â”‚    â”‚
â”‚  â”‚    b. Execute LLMInvocationStep                         â”‚    â”‚
â”‚  â”‚    c. Send events via IterationObserver                 â”‚    â”‚
â”‚  â”‚    d. Check ExecutionSignal                             â”‚    â”‚
â”‚  â”‚    e. If tool calls: Execute ToolExecutionStep          â”‚    â”‚
â”‚  â”‚    f. Send events via IterationObserver                 â”‚    â”‚
â”‚  â”‚    g. Notify: OnIterationEnd                            â”‚    â”‚
â”‚  â”‚ 4. Notify observers: OnFinish                           â”‚    â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                            â”‚
                            â”‚ Returns
                            â–¼
                      â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
                      â”‚ChainOutputâ”‚
                      â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## Execution Flow Diagram

```
User Request
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ReActCycle.Execute(ctx, input)                                     â”‚
â”‚                                                                   â”‚
â”‚ 1. Validate dependencies (read-only, no lock)                     â”‚
â”‚ 2. Read runtime defaults with RLock                               â”‚
â”‚ 3. Create ReActExecution (isolated runtime state)                 â”‚
â”‚ 4. Create ReActExecutor                                           â”‚
â”‚ 5. Register observers:                                            â”‚
â”‚    - ChainDebugRecorder (if not nil)                              â”‚
â”‚    - EmitterObserver (if emitter not nil)                         â”‚
â”‚    - EmitterIterationObserver (if emitter not nil)                â”‚
â”‚ 6. Execute: return executor.Execute(ctx, execution)               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ReActExecutor.Execute(ctx, exec)                                  â”‚
â”‚                                                                   â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚ â”‚ Observer: OnStart(ctx, exec)                                â”‚  â”‚
â”‚ â”‚  â”œâ”€ ChainDebugRecorder.Start(input)                         â”‚  â”‚
â”‚ â”‚  â””â”€ EmitterObserver: (no action)                            â”‚  â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                   â”‚
â”‚ Append user message to chainCtx.Messages                          â”‚
â”‚                                                                   â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚ â”‚ ITERATION LOOP (up to MaxIterations)                        â”‚  â”‚
â”‚ â”‚                                                              â”‚  â”‚
â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚  â”‚
â”‚ â”‚ â”‚ Observer: OnIterationStart(n)                           â”‚â”‚  â”‚
â”‚ â”‚ â”‚  â””â”€ ChainDebugRecorder.StartIteration(n)               â”‚â”‚  â”‚
â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚
â”‚ â”‚                                                              â”‚  â”‚
â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚  â”‚
â”‚ â”‚ â”‚ LLMInvocationStep.Execute()                             â”‚â”‚  â”‚
â”‚ â”‚ â”‚  â”œâ”€ Get model from ModelRegistry                         â”‚â”‚  â”‚
â”‚ â”‚ â”‚  â”œâ”€ Build messages with system prompt                    â”‚â”‚  â”‚
â”‚ â”‚ â”‚  â”œâ”€ Call LLM (with streaming if enabled)                 â”‚â”‚  â”‚
â”‚ â”‚ â”‚  â”œâ”€ Append assistant message to history                  â”‚â”‚  â”‚
â”‚ â”‚ â”‚  â””â”€ Return StepResult{Action, Signal}                    â”‚â”‚  â”‚
â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚
â”‚ â”‚                                                              â”‚  â”‚
â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚  â”‚
â”‚ â”‚ â”‚ IterationObserver.EmitThinking()                         â”‚â”‚  â”‚
â”‚ â”‚ â”‚ IterationObserver.EmitToolCall() (for each tool call)    â”‚â”‚  â”‚
â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚
â”‚ â”‚                                                              â”‚  â”‚
â”‚ â”‚ Check Signal:                                                â”‚  â”‚
â”‚ â”‚  â”œâ”€ SignalFinalAnswer â†’ BREAK                               â”‚  â”‚
â”‚ â”‚  â”œâ”€ SignalNeedUserInput â†’ BREAK                             â”‚  â”‚
â”‚ â”‚  â””â”€ SignalNone â†’ continue if no tool calls                  â”‚  â”‚
â”‚ â”‚                                                              â”‚  â”‚
â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚  â”‚
â”‚ â”‚ â”‚ ToolExecutionStep.Execute()                             â”‚â”‚  â”‚
â”‚ â”‚ â”‚  â”œâ”€ For each tool call:                                  â”‚â”‚  â”‚
â”‚ â”‚ â”‚  â”‚  â”œâ”€ Get tool from ToolsRegistry                       â”‚â”‚  â”‚
â”‚ â”‚ â”‚  â”‚  â”œâ”€ Execute tool with argsJSON                        â”‚â”‚  â”‚
â”‚ â”‚ â”‚  â”‚  â”œâ”€ Record result                                     â”‚â”‚  â”‚
â”‚ â”‚ â”‚  â”‚  â””â”€ Append tool message to history                    â”‚â”‚  â”‚
â”‚ â”‚ â”‚  â””â”€ Return StepResult{Action, Signal}                    â”‚â”‚  â”‚
â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚
â”‚ â”‚                                                              â”‚  â”‚
â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚  â”‚
â”‚ â”‚ â”‚ IterationObserver.EmitToolResult()                       â”‚â”‚  â”‚
â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚
â”‚ â”‚                                                              â”‚  â”‚
â”‚ â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”â”‚  â”‚
â”‚ â”‚ â”‚ Observer: OnIterationEnd(n)                             â”‚â”‚  â”‚
â”‚ â”‚ â”‚  â””â”€ ChainDebugRecorder.EndIteration()                   â”‚â”‚  â”‚
â”‚ â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜â”‚  â”‚
â”‚ â”‚                                                              â”‚  â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                   â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚ â”‚ IterationObserver.EmitMessage(result)                       â”‚  â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                   â”‚
â”‚ Build ChainOutput:                                               â”‚
â”‚  â”œâ”€ Result (last message content)                                â”‚
â”‚  â”œâ”€ Iterations                                                   â”‚
â”‚  â”œâ”€ Duration                                                     â”‚
â”‚  â”œâ”€ FinalState                                                   â”‚
â”‚  â”œâ”€ Signal                                                       â”‚
â”‚  â””â”€ DebugPath (filled by observer)                               â”‚
â”‚                                                                   â”‚
â”‚ â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”‚
â”‚ â”‚ Observer: OnFinish(output, nil)                             â”‚  â”‚
â”‚ â”‚  â”œâ”€ ChainDebugRecorder.Finalize() â†’ fills DebugPath         â”‚  â”‚
â”‚ â”‚  â””â”€ EmitterObserver.Emit(EventDone)                         â”‚  â”‚
â”‚ â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â”‚
â”‚                                                                   â”‚
â”‚ return output, nil                                                â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
     â”‚
     â–¼
 ChainOutput
```

---

## Thread Safety Model

### ReActCycle (Template)
- **Immutable fields**: Model registry, tools registry, config (immutable part)
- **Mutable defaults**: `config.DefaultEmitter`, `config.DefaultDebugRecorder`, `config.StreamingEnabled`
- **Protection**: `sync.RWMutex` for runtime defaults (reads with RLock, writes with Lock)
- **Concurrent execution**: Multiple `Execute()` calls can run simultaneously

### ReActExecution (Runtime)
- **Never shared**: Created per `Execute()` call, never passed between goroutines
- **No synchronization needed**: Each execution has its own isolated state

### ReActExecutor
- **Observers list**: Set before `Execute()`, never modified during execution
- **No synchronization**: Observers are added before execution starts

### Observers
- **ChainDebugRecorder**: Stores `startTime` field per execution (not shared)
- **EmitterObserver**: Stateless wrapper around `events.Emitter`
- **EmitterIterationObserver**: Stateless wrapper around `events.Emitter`

---

## Testing

All phases include comprehensive tests:

```bash
# Run all chain package tests
go test ./pkg/chain/... -v

# Run with race detector
go test ./pkg/chain/... -race

# Specific test coverage:
# - executor_test.go: StepExecutor, observers, concurrent execution
# - step_test.go: ExecutionSignal, StepResult, signal propagation
# - react_test.go: ReActCycle lifecycle, thread safety
```

---

## References

- Refactoring Plan: `refactoring_plan_for_ReAct_cycle.md`
- Implementation: `pkg/chain/`
- Test Coverage: `pkg/chain/*_test.go`
