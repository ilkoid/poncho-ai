# Анализ проекта Poncho AI

## 1. О проекте

### Назначение и основная цель проекта

Poncho AI - это интеллектуальный помощник для автоматизации процессов создания и управления карточками товаров на платформе Wildberries. Основная цель проекта - использование искусственного интеллекта для анализа визуальных материалов (эскизов, фотографий) и автоматической генерации контента для карточек товаров с учетом требований и ограничений платформы Wildberries.

Проект использует современные подходы к обработке естественного языка и компьютерного зрения для анализа изображений и текстового описания товаров, после чего автоматически формирует корректные карточки товаров с необходимыми атрибутами, характеристиками и классификацией в соответствии с каталогом Wildberries.

### Архитектурная структура

Проект построен по модульной архитектуре с четким разделением ответственности между компонентами:

```
poncho-ai/
├── internal/           Внутренние пакеты приложения
│   ├── app/           Ядро приложения - глобальное состояние и команды
│   └── ui/            Пользовательский интерфейс на базе Bubble Tea
├── pkg/               Переиспользуемые пакеты
│   ├── classifier/    Классификатор файлов
│   ├── config/        Управление конфигурацией
│   ├── factory/       Фабрики для создания объектов
│   ├── llm/           Абстракции для работы с LLM провайдерами
│   ├── prompt/        Система управления промптами
│   ├── s3storage/     Клиент для S3-совместимого хранилища
│   ├── todo/          Менеджер задач
│   ├── tools/         Реестр инструментов для AI-агента
│   └── wb/            Клиент для API Wildberries
├── cfg/               Файлы конфигурации
├── cli/               Интерфейс командной строки
└── clients/           Клиенты внешних сервисов
```

### Основные компоненты и их взаимодействие

1. **GlobalState** (`internal/app/state.go`) - центральное хранилище состояния приложения, реализующее паттерн "Single Source of Truth". Содержит конфигурацию, историю сообщений, файлы и результаты их анализа, текущие задачи.

2. **CommandRegistry** (`internal/app/commands.go`) - реестр команд, который обрабатывает пользовательский ввод и преобразует его в асинхронные операции.

3. **UI Layer** (`internal/ui/`) - интерфейс пользователя на основе Bubble Tea, состоящий из модели (model.go), обновления состояния (update.go), отрисовки (view.go) и стилей (styles.go).

4. **LLM Abstraction** (`pkg/llm/`) - унифицированный интерфейс для работы с различными провайдерами языковых моделей (OpenAI, ZAI и др.).

5. **Tools Registry** (`pkg/tools/`) - система расширения функциональности через инструменты, которые может вызывать AI-агент.

6. **Wildberries Client** (`pkg/wb/`) - клиент для взаимодействия с API Wildberries, включая работу со справочниками, каталогами и характеристиками товаров.

7. **File Classifier** (`pkg/classifier/`) - система классификации файлов по типам на основе конфигурируемых правил.

8. **Todo Manager** (`pkg/todo/`) - система управления задачами, которую использует AI-агент для планирования и отслеживания прогресса.

### Технологический стек

- **Язык программирования**: Go
- **UI фреймворк**: Bubble Tea (TUI)
- **Хранилище**: S3-совместимое объектное хранилище
- **AI/ML**: Интеграция с различными LLM провайдерами через унифицированный интерфейс
- **Конфигурация**: YAML с поддержкой переменных окружения
- **API интеграция**: REST API Wildberries с поддержкой rate limiting
- **Обработка изображений**: Библиотека для ресайза и конвертации в base64

## 2. Основные принципы архитектуры

### Принципы организации кода

1. **Разделение ответственности**: Каждый пакет имеет четкую зону ответственности и минимальные зависимости от других пакетов.

2. **Инверсия зависимостей**: Высокоуровневые модули не зависят от низкоуровневых, а оба зависят от абстракций (интерфейсов).

3. **Единое состояние**: Глобальное состояние приложения управляется централизованно через `GlobalState`, что обеспечивает консистентность данных.

4. **Асинхронность**: Операции, которые могут блокировать интерфейс, выполняются асинхронно через механизм команд Bubble Tea.

5. **Конфигурируемость**: Все аспекты системы настраиваются через YAML-конфигурацию с поддержкой переменных окружения.

### Паттерны проектирования

1. **Singleton**: `GlobalState` реализует паттерн одиночки для управления состоянием приложения.

2. **Registry**: Паттерн реестра используется для команд (`CommandRegistry`) и инструментов (`ToolsRegistry`).

3. **Factory**: Фабрики используются для создания провайдеров LLM (`NewLLMProvider`).

4. **Strategy**: Паттерн стратегии реализован в архитектуре LLM провайдеров, где каждый провайдер реализует общий интерфейс.

5. **Command**: Паттерн команды используется для инкапсуляции действий, которые могут выполняться асинхронно.

6. **Observer**: UI обновляется на основе изменений состояния через механизм сообщений Bubble Tea.

### Подходы к управлению состоянием

1. **Централизованное состояние**: Все состояние приложения хранится в `GlobalState`, который является "единственным источником правды".

2. **Потокобезопасность**: Критические секции состояния защищены мьютексами (`sync.RWMutex`) для безопасного доступа из разных горутин.

3. **Иммутабельность данных**: Вместо прямого изменения данных предпочтение отдается созданию новых состояний.

4. **Контекстное управление**: Состояние контекста для LLM формируется динамически на основе текущих данных, истории и задач.

5. **Разделение постоянного и временного состояния**: Конфигурация отделяется от runtime-данных, которые меняются в процессе работы.

### Модульность и инкапсуляция

1. **Пакетная организация**: Код организован в пакеты с четкими границами и минимальными публичными API.

2. **Интерфейсная инкапсуляция**: Внутренняя реализация скрыта за интерфейсами, что позволяет менять реализацию без влияния на использующий код.

3. **Слабая связанность**: Компоненты слабо связаны друг с другом и взаимодействуют через четко определенные API.

4. **Высокая связность**: Внутри каждого пакета функциональность тесно связана и логически завершена.

5. **Скрываемость реализации**: Детали реализации скрыты внутри пакетов, а наружу выставляются только необходимые абстракции.

## 3. Манифест реализации нового функционала

### Правила добавления новых компонентов

1. **Определите зону ответственности**: Новый компонент должен иметь четкую и ограниченную зону ответственности, не пересекающуюся с существующими компонентами.

2. **Следуйте пакетной структуре**: Размещайте новый код в соответствующем пакете в соответствии с его назначением:
   - Бизнес-логика приложения → `internal/app/`
   - Компоненты UI → `internal/ui/`
   - Переиспользуемые утилиты → `pkg/`
   - Интеграции с внешними сервисами → `clients/`

3. **Реализуйте необходимые интерфейсы**: Если компонент должен интегрироваться с существующей системой, реализуйте соответствующие интерфейсы.

4. **Добавьте конфигурацию**: Если компонент требует настройки, добавьте соответствующие секции в конфигурационный файл.

5. **Обеспечьте потокобезопасность**: Если компонент будет использоваться из нескольких горутин, обеспечьте правильную синхронизацию.

6. **Напишите тесты**: Покройте новый функционал тестами, включая unit-тесты и интеграционные тесты.

### Принципы интеграции с существующей архитектурой

1. **Используйте GlobalState**: Для хранения состояния компонента используйте централизованное состояние приложения.

2. **Регистрируйте команды**: Если компонент должен реагировать на пользовательский ввод, зарегистрируйте соответствующие команды в `CommandRegistry`.

3. **Добавляйте инструменты**: Если компонент предоставляет функциональность, которую может вызывать AI-агент, реализуйте интерфейс `Tool` и зарегистрируйте его в `ToolsRegistry`.

4. **Следуйте паттерну обновления UI**: Используйте механизм сообщений Bubble Tea для обновления интерфейса.

5. **Интегрируйте с LLM**: Если компонент должен взаимодействовать с языковыми моделями, используйте унифицированный интерфейс `llm.Provider`.

6. **Соблюдайте асинхронность**: Длительные операции выполняйте асинхронно, чтобы не блокировать пользовательский интерфейс.

### Рекомендации по расширению функционала

1. **Добавление новых LLM провайдеров**:
   - Реализуйте интерфейс `llm.Provider` в новом пакете внутри `pkg/llm/`
   - Добавьте фабрику в `pkg/factory/`
   - Расширьте конфигурацию для поддержки нового провайдера

2. **Добавление новых инструментов для AI-агента**:
   - Реализуйте интерфейс `tools.Tool` в новом файле
   - Определите схему параметров в методе `Definition()`
   - Зарегистрируйте инструмент в `ToolsRegistry`

3. **Расширение UI**:
   - Добавьте новые компоненты в соответствующие файлы в `internal/ui/`
   - Определите стили в `internal/ui/styles.go`
   - Обновите модель и логику обновления в `model.go` и `update.go`

4. **Интеграция с новыми внешними API**:
   - Создайте клиент в `pkg/` или `clients/`
   - Реализуйте необходимые инструменты для доступа к API
   - Добавьте конфигурацию для подключения

5. **Расширение системы классификации файлов**:
   - Добавьте новые правила в конфигурацию
   - Расширьте логику в `pkg/classifier/` при необходимости

### Лучшие практики разработки в контексте этого проекта

1. **Следуйте Go идиомам**: Используйте идиоматичный Go код, следуйте рекомендациям по оформлению и именованию.

2. **Обрабатывайте ошибки**: Всегда обрабатывайте ошибки явно и возвращайте их вверх по стеку вызовов.

3. **Используйте контекст**: Для операций, которые могут быть отменены или имеют таймауты, используйте `context.Context`.

4. **Документируйте код**: Добавляйте комментарии к экспортируемым функциям и сложным алгоритмам.

5. **Избегайте глобальных переменных**: Вместо глобальных переменных используйте зависимость от `GlobalState` или передачу через параметры.

6. **Тестируйте критический путь**: Убедитесь, что основные сценарии использования покрыты тестами.

7. **Следуйте принципу наименьшего удивления**: Поведение компонентов должно быть интуитивно понятным и предсказуемым.

8. **Валидируйте входные данные**: Проверяйте входные данные на корректность, особенно при взаимодействии с внешними API.

9. **Логируйте важные операции**: Добавляйте логирование для важных операций, особенно при взаимодействии с внешними системами.

10. **Следуйте семантическому версионированию**: При изменении API следуйте принципам семантического версионирования.