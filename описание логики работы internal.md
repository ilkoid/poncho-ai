# описание логики работы internal/app и internal/ui в формате архитектурной документации. 

Это поможет вам или другому разработчику быстро понять, "где что лежит" и "почему оно работает именно так".

## Архитектура ядра (Internal Core Documentation)
Этот документ описывает внутреннее устройство фреймворка Poncho AI, разделяя его на "Мозг/Память" (app) и "Интерфейс/Контроллер" (ui).

### 1. Пакет internal/app (Global State & Logic)
Назначение:
Это центральная нервная система приложения. Здесь хранится "Истина" (Single Source of Truth). Пакет полностью отвязан от интерфейса (UI) — он не знает, рисуете вы кнопки в терминале или отдаете JSON по HTTP.

#### Ключевые компоненты:

GlobalState (Структура):

Хранит конфигурацию, клиенты (S3, WB) и текущие данные сессии.

Working Memory (Files): Это не просто список файлов. Это "умный кеш". Когда Vision-модель описывает картинку, текст сохраняется именно сюда (FileMeta.VisionDescription). Это позволяет не отправлять картинку в LLM повторно.
​

#### History (History): Хронология диалога.

Потокобезопасность (Thread Safety):

Используется sync.RWMutex.
​

Почему это важно: UI работает в одном потоке (отрисовывает спиннер), а сетевые запросы к LLM/S3 идут в фоновых горутинах. Без мьютексов приложение упадет с concurrent map read/write.

#### Логика RAG (Retrieval-Augmented Generation):

Метод BuildAgentContext — это "сборщик контекста".

Перед каждым запросом к LLM он "высасывает" текстовые описания из Files и склеивает их с системным промптом.

LLM "думает", что видит файлы, но на самом деле видит только подготовленный текст.

#### Главное правило разработки в app:

Здесь нет fmt.Println или логики отображения. Только данные и их мутация.

### 2. Пакет internal/ui (Terminal Interface & Controller)
#### Назначение:
Реализация взаимодействия с пользователем через TUI (Text User Interface) на базе архитектуры The Elm Architecture (TEA).

#### Архитектурный цикл (TEA):
Весь UI работает в бесконечном цикле:
Model (Данные) -> View (Отрисовка) -> Update (Событие) -> Model (Новые данные)

#### Ключевые файлы и их роль:

model.go (Состояние UI):

Хранит только данные для отображения: содержимое текстового поля (textarea), позицию скролла (viewport), размер окна терминала.

Имеет ссылку на app.GlobalState, чтобы читать бизнес-данные.

view.go (Рендер):

Чистая функция. Превращает состояние в строку.

Здесь задается верстка: "Хедер сверху, чат посередине, ввод снизу".

Использует библиотеку lipgloss для стилей (цвета, рамки).
​

update.go (Контроллер и События):

Это "сердце" интерфейса. Обрабатывает нажатия клавиш.

Синхронная логика: Если нажали букву — обнови textarea.

Асинхронная логика (tea.Cmd): Если нажали Enter — запусти тяжелую задачу (сеть/AI).

UI никогда не должен зависать. Все тяжелое оборачивается в функцию performCommand и возвращает tea.Cmd.

performCommand (Диспетчер команд):

Парсит текстовую строку (например, load 12345).

Вызывает методы из pkg/ (например, классификатор или S3).

Обновляет app.GlobalState (под мьютексом).

Возвращает сообщение-результат (CommandResultMsg), которое снова попадет в Update.

#### Главное правило разработки в ui:

Никакой бизнес-логики (типа "как ходить в S3") внутри View.

Никаких блокирующих операций (долгих sleep или HTTP-запросов) напрямую в Update — только через возврат tea.Cmd.

#### Сводная схема взаимодействия
Если надо добавить новую фичу (например, кнопку "Очистить контекст"), логика изменений будет такой:

В internal/app: Добавить метод ClearContext(), который обнуляет Files и History (под защитой Mutex).

В internal/ui/update.go: В performCommand добавить case "clear": state.ClearContext().

В internal/ui/view.go: (Опционально) Отобразить уведомление "Контекст очищен".

Такое разделение позволяет менять логику (как мы храним данные) не ломая верстку, и менять верстку (цвета, расположение) не ломая логику данных.
