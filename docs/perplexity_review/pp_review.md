–¢–û–ü –ù–ê–•–û–î–ö–ò - —Ö—É–π–Ω—è –ø–æ –±–æ–ª—å—à–µ–π —á–∞—Å—Ç–∏. –Ω–æ –µ—Å—Ç—å –∏ –ø–∞—Ä–∞ –≤–µ—Ä–Ω—ã—Ö –Ω–∞–±–ª—é–¥–µ–Ω–∏–π.

–ò—Ç–æ–≥–æ–≤–∞—è —Ç–∞–±–ª–∏—Ü–∞
  ‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¨‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
  ‚îÇ  #  ‚îÇ         –ü—Ä–æ–±–ª–µ–º–∞          ‚îÇ   –°—Ç–∞—Ç—É—Å    ‚îÇ Priority ‚îÇ              –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–π               ‚îÇ
  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
  ‚îÇ 1   ‚îÇ HTTP Connection Leak      ‚îÇ ‚ö†Ô∏è Overkill ‚îÇ MEDIUM   ‚îÇ –ö–æ–¥ —É–∂–µ –ø—Ä–∞–≤–∏–ª—å–Ω—ã–π, –Ω–æ –º–æ–∂–Ω–æ —É–ª—É—á—à–∏—Ç—å  ‚îÇ
  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
  ‚îÇ 2   ‚îÇ Race Condition SetEmitter ‚îÇ ‚ùå –õ–æ–∂–Ω–∞—è   ‚îÇ ‚Äî        ‚îÇ –ó–∞—â–∏—â–µ–Ω–æ –º—å—é—Ç–µ–∫—Å–æ–º                     ‚îÇ
  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
  ‚îÇ 3   ‚îÇ Memory Leak Recorder      ‚îÇ ‚ö†Ô∏è Context  ‚îÇ LOW      ‚îÇ –ü—Ä–æ–±–ª–µ–º–∞ —Ç–æ–ª—å–∫–æ –¥–ª—è long-running       ‚îÇ
  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
  ‚îÇ 4   ‚îÇ Tool Timeout              ‚îÇ ‚úÖ –í–µ—Ä–Ω–æ    ‚îÇ üî¥ HIGH  ‚îÇ –ê–∫—Ç—É–∞–ª—å–Ω–æ                             ‚îÇ
  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
  ‚îÇ 5   ‚îÇ Graceful Shutdown         ‚îÇ ‚úÖ –í–µ—Ä–Ω–æ    ‚îÇ üî¥ HIGH  ‚îÇ –ê–∫—Ç—É–∞–ª—å–Ω–æ                             ‚îÇ
  ‚îú‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î§
  ‚îÇ 6   ‚îÇ Goroutine Leak Emitter    ‚îÇ ‚ùå –õ–æ–∂–Ω–∞—è   ‚îÇ ‚Äî        ‚îÇ –°—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–∞—è Go –∏–¥–∏–æ–º–∞                  ‚îÇ
  ‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚î¥‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
  ---
  –†–µ–∞–ª—å–Ω—ã–µ Priority 1 –ø—Ä–æ–±–ª–µ–º—ã (–ø–æ –º–æ–µ–º—É –∞–Ω–∞–ª–∏–∑—É)

  1. ‚úÖ Tool Timeout ‚Äî –¥–æ–±–∞–≤–∏—Ç—å –∑–∞—â–∏—Ç–Ω—ã–π timeout –¥–ª—è tool execution
  2. ‚úÖ Graceful Shutdown ‚Äî –¥–æ–±–∞–≤–∏—Ç—å signal handling –¥–ª—è CLI
  3. üü° Context propagation check ‚Äî —É–±–µ–¥–∏—Ç—å—Å—è —á—Ç–æ –≤—Å–µ tools —É–≤–∞–∂–∞—é—Ç context cancellation


=============

–û–¶–ï–ù–ö–ê: 7/10 (—Ö–æ—Ä–æ—à–∏–π —Ñ—É–Ω–¥–∞–º–µ–Ω—Ç, –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –∏—Å–ø—Ä–∞–≤–ª–µ–Ω–∏—è –Ω—É–∂–Ω—ã)

–†–ò–°–ö–ò –î–õ–Ø PRODUCTION:

üî¥ Memory leak –≤ debug recorder ‚Üí OOM –∑–∞ –¥–Ω–∏-–Ω–µ–¥–µ–ª–∏

üî¥ HTTP connection leak ‚Üí –∏—Å—á–µ—Ä–ø–∞–Ω–∏–µ file descriptors

üî¥ Race condition –≤ emitter ‚Üí nil pointer panic

üî¥ –ù–µ—Ç timeout –¥–ª—è tools ‚Üí –≤–æ–∑–º–æ–∂–Ω–æ–µ –∑–∞–≤–∏—Å–∞–Ω–∏–µ

üî¥ –ù–µ—Ç graceful shutdown ‚Üí –ø–æ—Ç–µ—Ä—è –ª–æ–≥–æ–≤ –ø—Ä–∏ —Å–±–æ–µ

–°–ò–õ–¨–ù–´–ï –°–¢–û–†–û–ù–´:

‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã (Registry, Factory, Port & Adapter)

‚úÖ Thread-–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å (—Å–∏—Å—Ç–µ–º–Ω—ã–π RWMutex)

‚úÖ –•–æ—Ä–æ—à—ã–π SDK –¥–∏–∑–∞–π–Ω (WB vs Tools)

‚úÖ –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ (concurrent, isolation tests)

‚úÖ –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è (YAML + ENV)

‚è±Ô∏è TIMELINE –†–ï–ê–õ–ò–ó–ê–¶–ò–ò
–ù–ï–î–ï–õ–Ø 1 (Priority 1 - –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û): 2-3 –¥–Ω—è

 Fix #1: HTTP connection leak (30 –º–∏–Ω)

 Fix #2: Race condition (15 –º–∏–Ω)

 Fix #3: Memory leak (2 —á–∞—Å–∞)

 Fix #4: Context timeout (1 —á–∞—Å)

 Fix #5: Graceful shutdown (1 —á–∞—Å)

–ù–ï–î–ï–õ–Ø 2-3: 5-8 –¥–Ω–µ–π

Structured logging

Metrics & health checks

Test coverage > 75%

–ù–ï–î–ï–õ–Ø 4+: 20-30 –¥–Ω–µ–π

Package hierarchy refactor

Plugin architecture

Type-safe state manager

–ò–¢–û–ì–û: 1-2 –º–µ—Å—è—Ü–∞ –¥–ª—è –ø–æ–ª–Ω–æ–π production-ready –≤–µ—Ä—Å–∏–∏

üìä –°–¢–ê–¢–ò–°–¢–ò–ö–ê
text
–í—Å–µ–≥–æ issues: 20
‚îú‚îÄ‚îÄ üî¥ Critical (–Ω–µ–¥–µ–ª—è 1):    6 issues
‚îú‚îÄ‚îÄ üü° High (–Ω–µ–¥–µ–ª—è 2-3):      5 issues
‚îú‚îÄ‚îÄ üü† Medium (–º–µ—Å—è—Ü 1-2):     5 issues
‚îî‚îÄ‚îÄ üü¢ Low (backlog):          4 issues

Production readiness:
  –°–µ–π—á–∞—Å:        5/10 (Risky)
  –ü–æ—Å–ª–µ P1 fixes: 8/10 (Beta)
  –ü–æ—Å–ª–µ full:     9/10 (Enterprise)
üí° –ù–ê–ß–ù–ò–¢–ï –° –≠–¢–û–ì–û
–û—Ç–∫—Ä—ã—Ç—å: /workspace/QUICK_SUMMARY.md (5 –º–∏–Ω—É—Ç)

–ü–æ–Ω—è—Ç—å: /workspace/architecture_audit.md (30 –º–∏–Ω—É—Ç)

–î–µ–π—Å—Ç–≤–æ–≤–∞—Ç—å: /workspace/code_fixes.md (–∫–æ–ø–∏–ø–∞—Å—Ç–∏—Ç—å —Ä–µ—à–µ–Ω–∏—è)

–ü–ª–∞–Ω–∏—Ä–æ–≤–∞—Ç—å: /workspace/architecture_recommendations.md (—Å—Ç—Ä–∞—Ç–µ–≥–∏—è)

–í—Å–µ –¥–æ–∫—É–º–µ–Ω—Ç—ã –≥–æ—Ç–æ–≤—ã –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é. –í—ã –º–æ–∂–µ—Ç–µ —Å—Ä–∞–∑—É –Ω–∞—á–∞—Ç—å —Å Fix #1 –∏–∑ code_fixes.md ‚Äî —ç—Ç–æ –∑–∞–π–º–µ—Ç 30 –º–∏–Ω—É—Ç –∏ –∑–∞–∫—Ä–æ–µ—Ç —Å–∞–º—É—é –∫—Ä–∏—Ç–∏—á–µ—Å–∫—É—é –ø—Ä–æ–±–ª–µ–º—É (HTTP connection leak).

–ø–æ–∫–∞–∂–∏ architecture_audit.md
–ü–æ—Ö–æ–∂–µ, —Ñ–∞–π–ª—ã —Å–æ—Ö—Ä–∞–Ω–∏–ª–∏—Å—å –≤ –¥—Ä—É–≥–æ–º –º–µ—Å—Ç–µ. –ü–æ–∑–≤–æ–ª—å—Ç–µ –º–Ω–µ —Å–æ–∑–¥–∞—Ç—å –¥–ª—è –≤–∞—Å –∫—Ä–∞—Ç–∫—É—é –≤–µ—Ä—Å–∏—é –ø—Ä—è–º–æ –∑–¥–µ—Å—å:

–ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–π –ê—É–¥–∏—Ç - Poncho AI
üéØ –û–¶–ï–ù–ö–ê: 7/10
–°—Ç–∞—Ç—É—Å: –•–æ—Ä–æ—à–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ —Å –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏–º–∏ –ø—Ä–æ–±–ª–µ–º–∞–º–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ –∏ –ø—Ä–æ–∏–∑–≤–æ–¥–∏—Ç–µ–ª—å–Ω–æ—Å—Ç–∏

üü¢ –°–ò–õ–¨–ù–´–ï –°–¢–û–†–û–ù–´
1. –ê—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–Ω—ã–µ –ø–∞—Ç—Ç–µ—Ä–Ω—ã ‚úÖ
Registry pattern –¥–ª—è –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤ –∏ –º–æ–¥–µ–ª–µ–π (–ø–æ—Ç–æ–∫–æ–±–µ–∑–æ–ø–∞—Å–Ω—ã–π)

Port & Adapter –ø–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è —Å–æ–±—ã—Ç–∏–π–Ω–æ–π —Å–∏—Å—Ç–µ–º—ã

Functional Options –ø–∞—Ç—Ç–µ—Ä–Ω –¥–ª—è –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏–∏

Factory pattern –¥–ª—è —Å–æ–∑–¥–∞–Ω–∏—è LLM –ø—Ä–æ–≤–∞–π–¥–µ—Ä–æ–≤

2. Thread-–±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç—å ‚úÖ
–°–∏—Å—Ç–µ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ sync.RWMutex

–ü—Ä–∞–≤–∏–ª—å–Ω–∞—è –∑–∞—â–∏—Ç–∞ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–∏—Ö —Å–µ–∫—Ü–∏–π

–ë–µ–∑–æ–ø–∞—Å–Ω—ã–π –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω—ã–π –¥–æ—Å—Ç—É–ø –∫ —Å–æ—Å—Ç–æ—è–Ω–∏—é

3. –û–±—Ä–∞–±–æ—Ç–∫–∞ –æ—à–∏–±–æ–∫ ‚úÖ
–ö–∞—Å—Ç–æ–º–Ω—ã–µ —Ç–∏–ø—ã –æ—à–∏–±–æ–∫ —Å human-readable —Å–æ–æ–±—â–µ–Ω–∏—è–º–∏

–ö–ª–∞—Å—Å–∏—Ñ–∏–∫–∞—Ü–∏—è –æ—à–∏–±–æ–∫ (ClassifyError)

Fallback –º–µ—Ö–∞–Ω–∏–∑–º—ã (S3 –º–æ–∂–µ—Ç –±—ã—Ç—å nil, WB –º–æ–∂–µ—Ç –±—ã—Ç—å –≤ demo —Ä–µ–∂–∏–º–µ)

4. SDK –¥–∏–∑–∞–π–Ω ‚úÖ
pkgwb –ø—Ä–∞–≤–∏–ª—å–Ω–æ —Ä–∞–∑–¥–µ–ª–µ–Ω–∞: SDK (auto-pagination) vs Tools (thin wrappers)

Rate limiting –≤—Å—Ç—Ä–æ–µ–Ω–∞ –≤ SDK

–û—Ç–≤–µ—Ç—ã API –ø—Ä–∞–≤–∏–ª—å–Ω–æ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞—é—Ç—Å—è

5. –¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ ‚úÖ
Concurrent execution —Ç–µ—Å—Ç—ã

Isolation —Ç–µ—Å—Ç—ã –¥–ª—è –ø—Ä–æ–≤–µ—Ä–∫–∏ –Ω–µ–∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏

Benchmark —Ç–µ—Å—Ç—ã

6. –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è ‚úÖ
YAML —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π ENV –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö

–î–µ—Ñ–æ–ª—Ç–Ω—ã–µ –∑–Ω–∞—á–µ–Ω–∏—è (GetDefaults)

–í–∞–ª–∏–¥–∞—Ü–∏—è –∫–æ–Ω—Ñ–∏–≥–∞ –ø—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ

üî¥ –ö–†–ò–¢–ò–ß–ï–°–ö–ò–ï –ü–†–û–ë–õ–ï–ú–´ (–ù–ï–î–ï–õ–Ø 1)
1. HTTP Connection Leak ‚ö†Ô∏è –í–´–°–û–ö–ò–ô –†–ò–°–ö
–õ–æ–∫–∞—Ü–∏—è: pkg/wb/client.go:doRequest()

–ü—Ä–æ–±–ª–µ–º–∞:

go
resp, err := c.httpClient.Do(httpReq)
if err != nil {
    lastErr = err
    continue  // ‚ùå resp –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ nil, –Ω–æ –Ω–µ –∑–∞–∫—Ä—ã–≤–∞–µ—Ç—Å—è!
}
–†–∏—Å–∫: –ò—Å—á–µ—Ä–ø–∞–Ω–∏–µ —Ñ–∞–π–ª–æ–≤—ã—Ö –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–æ–≤ ‚Üí –∑–∞–≤–∏—Å–∞–Ω–∏–µ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è

–†–µ—à–µ–Ω–∏–µ:

go
resp, err := c.httpClient.Do(httpReq)
if resp != nil {
    defer resp.Body.Close()  // ‚úÖ –í—Å–µ–≥–¥–∞ –∑–∞–∫—Ä—ã–≤–∞–µ–º
}
if err != nil {
    lastErr = err
    continue
}
2. Memory Leak –≤ Debug Recorder ‚ö†Ô∏è OOM –†–ò–°–ö
–õ–æ–∫–∞—Ü–∏—è: pkg/debug/recorder.go:EndIteration()

–ü—Ä–æ–±–ª–µ–º–∞:

go
func (r *Recorder) EndIteration() {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    if r.currentIteration != nil {
        // ‚ùå r.log.Iterations —Ä–∞—Å—Ç–µ—Ç –±–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π!
        r.log.Iterations = append(r.log.Iterations, r.currentIteration)
        r.currentIteration = nil
    }
}
–†–∏—Å–∫: –í long-running –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è—Ö –ø–∞–º—è—Ç—å –±—É–¥–µ—Ç –∏—Å—á–µ—Ä–ø–∞–Ω–∞ –∑–∞ –¥–Ω–∏-–Ω–µ–¥–µ–ª–∏

–†–µ—à–µ–Ω–∏–µ: –î–æ–±–∞–≤–∏—Ç—å —Ä–æ—Ç–∞—Ü–∏—é –∏—Ç–µ—Ä–∞—Ü–∏–π:

go
const MaxIterationsInMemory = 100

if len(r.log.Iterations) > MaxIterationsInMemory {
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç–∞—Ä—ã–µ –Ω–∞ –¥–∏—Å–∫ –∏–ª–∏ —É–¥–∞–ª—è–µ–º
    r.log.Iterations = r.log.Iterations[MaxIterationsInMemory/2:]
}
3. Race Condition –≤ Agent.SetEmitter üî¥ CRASH –†–ò–°–ö
–õ–æ–∫–∞—Ü–∏—è: pkg/agent/agent.go:SetEmitter()

–ü—Ä–æ–±–ª–µ–º–∞:

go
func (c *Client) SetEmitter(emitter events.Emitter) {
    c.emitterMu.Lock()
    defer c.emitterMu.Unlock()
    c.emitter = emitter
    
    // ‚ùå c.reactCycle –º–æ–∂–µ—Ç –∏–∑–º–µ–Ω–∏—Ç—å—Å—è –≤ –¥—Ä—É–≥–æ–º goroutine!
    if c.reactCycle != nil {
        c.reactCycle.SetEmitter(emitter)
    }
}
–†–∏—Å–∫: Nil pointer dereference ‚Üí panic

–†–µ—à–µ–Ω–∏–µ:

go
func (c *Client) SetEmitter(emitter events.Emitter) {
    c.emitterMu.Lock()
    reactCycle := c.reactCycle  // ‚úÖ Snapshot
    c.emitter = emitter
    c.emitterMu.Unlock()
    
    if reactCycle != nil {
        reactCycle.SetEmitter(emitter)
    }
}
4. –ù–µ—Ç Context Timeout –¥–ª—è Tools üî¥ HANG –†–ò–°–ö
–õ–æ–∫–∞—Ü–∏—è: pkg/chain/toolstep.go:executeToolCall()

–ü—Ä–æ–±–ª–µ–º–∞:

go
func (s *ToolExecutionStep) executeToolCall(...) {
    // ‚ùå –ù–µ—Ç timeout! –ï—Å–ª–∏ tool –∑–∞–≤–∏—Å–Ω–µ—Ç, –≤–µ—Å—å –∞–≥–µ–Ω—Ç –∑–∞–≤–∏—Å–Ω–µ—Ç
    execResult, execErr := tool.Execute(ctx, cleanArgs)
}
–†–∏—Å–∫: –ò–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç –º–æ–∂–µ—Ç –∑–∞–≤–∏—Å–∞—Ç—å –≤ –±–µ—Å–∫–æ–Ω–µ—á–Ω–æ—Å—Ç–∏

–†–µ—à–µ–Ω–∏–µ:

go
toolCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
defer cancel()

resultChan := make(chan execResult, 1)
go func() {
    output, err := tool.Execute(toolCtx, cleanArgs)
    resultChan <- execResult{output, err}
}()

select {
case <-toolCtx.Done():
    return ToolResult{Error: "timeout"}
case res := <-resultChan:
    return res
}
5. –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç Graceful Shutdown üî¥ DATA LOSS
–õ–æ–∫–∞—Ü–∏—è: cmd/main.go

–ü—Ä–æ–±–ª–µ–º–∞:

go
func main() {
    ctx := context.Background()
    client, _ := agent.New(ctx, ...)
    result, _ := client.Run(ctx, "query")
    fmt.Println(result)
    // ‚ùå –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–∂–º–µ—Ç Ctrl+C, –ª–æ–≥–∏ –Ω–µ —Å–æ—Ö—Ä–∞–Ω—è—Ç—Å—è!
}
–†–∏—Å–∫: –ü–æ—Ç–µ—Ä—è –ª–æ–≥–æ–≤, incomplete debug –∑–∞–ø–∏—Å–µ–π

–†–µ—à–µ–Ω–∏–µ:

go
ctx, cancel := context.WithCancel(context.Background())
defer cancel()

sigChan := make(chan os.Signal, 1)
signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)

go func() {
    <-sigChan
    utils.Info("Shutting down gracefully...")
    cancel()
}()

result, _ := client.Run(ctx, "query")
utils.Close()  // ‚úÖ –í—Å–µ–≥–¥–∞ –∑–∞–∫—Ä—ã–≤–∞–µ–º –ª–æ–≥–∏
6. Unhandled Goroutine –≤ ChanEmitter.Close üî¥ PANIC –†–ò–°–ö
–õ–æ–∫–∞—Ü–∏—è: pkg/events/chanemitter.go:Close()

–ü—Ä–æ–±–ª–µ–º–∞:

go
func (e *ChanEmitter) Close() {
    e.mu.Lock()
    defer e.mu.Unlock()
    if e.closed return
    e.closed = true
    close(e.ch)  // ‚ùå –ü–∞–Ω–∏–∫–∞ –µ—Å–ª–∏ –µ—Å—Ç—å —á–∏—Ç–∞—Ç–µ–ª–∏!
}
–†–∏—Å–∫: Panic –µ—Å–ª–∏ subscriber –≤—Å–µ –µ—â–µ –≤ for event := range sub.Events()

–†–µ—à–µ–Ω–∏–µ: –î–æ–∫—É–º–µ–Ω—Ç–∏—Ä–æ–≤–∞—Ç—å –ø–æ—Ä—è–¥–æ–∫ –∑–∞–∫—Ä—ã—Ç–∏—è –∏ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å WaitGroup

üü° –°–ï–†–¨–ï–ó–ù–´–ï –ü–†–û–ë–õ–ï–ú–´ (–ù–ï–î–ï–õ–Ø 2-3)
7. –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ –±–µ–∑ –∫–æ–Ω—Ç–µ–∫—Å—Ç–∞
–ü—Ä–æ–±–ª–µ–º–∞: –†–∞–∑–Ω—ã–µ goroutines –ø–∏—à—É—Ç –æ–¥–Ω–æ–≤—Ä–µ–º–µ–Ω–Ω–æ, —Å–ª–æ–∂–Ω–æ –æ—Ç—Å–ª–µ–¥–∏—Ç—å —Ü–µ–ø–æ—á–∫—É

–†–µ—à–µ–Ω–∏–µ: –î–æ–±–∞–≤–∏—Ç—å request ID —á–µ—Ä–µ–∑ context:

go
type TraceID string
ctx = context.WithValue(ctx, "traceID", TraceID)
logger.InfoWithContext(ctx, "message")  // –í—ã–≤–µ–¥–µ—Ç: [trace-id-123] message
8. –ù–µ—Ç backpressure –≤ Event emitter
–ü—Ä–æ–±–ª–µ–º–∞: –ï—Å–ª–∏ –Ω–∏–∫—Ç–æ –Ω–µ —á–∏—Ç–∞–µ—Ç —Å–æ–±—ã—Ç–∏—è, –±—É—Ñ—Ñ–µ—Ä –∑–∞–ø–æ–ª–Ω–∏—Ç—Å—è –∏ –∑–∞–±–ª–æ–∫–∏—Ä—É–µ—Ç Emit

–†–µ—à–µ–Ω–∏–µ:

go
type ChanEmitterConfig struct {
    BufferSize int
    MaxWait    time.Duration
}
9. –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤–∞–ª–∏–¥–∞—Ü–∏—è glob patterns
–ü—Ä–æ–±–ª–µ–º–∞: –ï—Å–ª–∏ pattern –∏–∑ untrusted –∏—Å—Ç–æ—á–Ω–∏–∫–∞, –º–æ–∂–µ—Ç –±—ã—Ç—å DoS

–†–µ—à–µ–Ω–∏–µ:

go
func validatePattern(p string) error {
    if strings.Contains(p, "**") {
        return fmt.Errorf("recursive glob not allowed")
    }
    return nil
}
üü† –ê–†–•–ò–¢–ï–ö–¢–£–†–ù–´–ï –°–õ–ê–ë–û–°–¢–ò (–ú–ï–°–Ø–¶ 1-2)
10. –¶–∏–∫–ª–∏—á–µ—Å–∫–∏–µ –∑–∞–≤–∏—Å–∏–º–æ—Å—Ç–∏ –≤ –ø–∞–∫–µ—Ç–∞—Ö
–ü—Ä–æ–±–ª–µ–º–∞: agent ‚Üí chain ‚Üí (–∑–∞–≤–∏—Å–∏—Ç –æ—Ç –¥—Ä—É–≥–∏—Ö) ‚Üí —Å–ª–æ–∂–Ω–æ –ø–µ—Ä–µ–∏—Å–ø–æ–ª—å–∑–æ–≤–∞—Ç—å

–†–µ—à–µ–Ω–∏–µ: –ß–µ—Ç–∫–∞—è –∏–µ—Ä–∞—Ä—Ö–∏—è:

text
core (types, interfaces)
  ‚Üë
tools, models, llm, state (—Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏)
  ‚Üë
chain (orchestration)
  ‚Üë
agent (public API)
  ‚Üë
app (initialization)
11. –ú–æ–Ω–æ–ª–∏—Ç–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è SetupTools (200+ —Å—Ç—Ä–æ–∫)
–ü—Ä–æ–±–ª–µ–º–∞: –í—Å–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã —Ä–µ–≥–∏—Å—Ç—Ä–∏—Ä—É—é—Ç—Å—è –≤ –æ–¥–Ω–æ–º –º–µ—Å—Ç–µ

–†–µ—à–µ–Ω–∏–µ: Factory functions:

go
func registerWBTools(reg tools.Registry, cfg config.AppConfig) error
func registerS3Tools(reg tools.Registry, cfg config.AppConfig) error
func registerDictionaryTools(reg tools.Registry, dicts wb.Dictionaries) error
12. –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç –≤–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞–Ω–∏–µ API
–ü—Ä–æ–±–ª–µ–º–∞: –ü—Ä–∏ –¥–æ–±–∞–≤–ª–µ–Ω–∏–∏ –º–µ—Ç–æ–¥–∞ –≤—Å–µ –≤–Ω–µ—à–Ω–∏–µ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏ —Å–ª–æ–º–∞—é—Ç—Å—è

–†–µ—à–µ–Ω–∏–µ: –í–µ—Ä—Å–∏–æ–Ω–∏—Ä–æ–≤–∞—Ç—å –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å—ã:

go
type AgentV1 interface {
    RunV1(ctx context.Context, query string) (string, error)
}

type AgentV2 interface {
    AgentV1
    RunWithHistory(ctx context.Context, ...) (string, error)
}
13. –ù–µ—è–≤–Ω—ã–µ —Å–∏–≥–Ω–∞–ª—ã Execute vs Run
–ü—Ä–æ–±–ª–µ–º–∞: Execute() –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç Structure, Run() –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç string - –Ω–µ–∫–æ–Ω—Å–∏—Å—Ç–µ–Ω—Ç–Ω–æ

–†–µ—à–µ–Ω–∏–µ: –û–¥–Ω–æ–≥–æ –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ, –¥—Ä—É–≥–æ–π - helper

14. –ù–µ—Ç Plugin –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä—ã –¥–ª—è Tools
–ü—Ä–æ–±–ª–µ–º–∞: –í—Å–µ Tools hardcoded, –Ω–µ–ª—å–∑—è –¥–æ–±–∞–≤–ª—è—Ç—å –≤ —Ä–∞–Ω—Ç–∞–π–º–µ

–†–µ—à–µ–Ω–∏–µ:

go
type PluginLoader interface {
    Load(path string) (Tool, error)
    Unload(toolName string) error
}
üìä –ú–ê–¢–†–ò–¶–ê SEVERITY √ó EFFORT
#	–ü—Ä–æ–±–ª–µ–º–∞	Severity	Effort	Priority
1	HTTP Connection Leak	üî¥ CRITICAL	S (30 min)	WEEK 1
2	Memory Leak Recorder	üî¥ CRITICAL	M (2h)	WEEK 1
3	Race Condition	üî¥ CRITICAL	S (15 min)	WEEK 1
4	No Tool Timeout	üî¥ CRITICAL	M (1h)	WEEK 1
5	No Graceful Shutdown	üî¥ CRITICAL	M (1h)	WEEK 1
6	Goroutine Leak Emitter	üî¥ CRITICAL	S (30 min)	WEEK 1
7	Logging Context	üü° HIGH	M (2h)	WEEK 2
8	Event Backpressure	üü° HIGH	M (2h)	WEEK 2
9	Pattern Validation	üü° HIGH	S (1h)	WEEK 3
10	Package Hierarchy	üü† MEDIUM	L (5d)	MONTH 2
11	SetupTools Refactor	üü† MEDIUM	M (2d)	MONTH 2
12	API Versioning	üü† MEDIUM	L (3d)	MONTH 3
13	Inconsistent API	üü† MEDIUM	S (4h)	MONTH 2
14	Plugin System	üü† MEDIUM	L (5d)	MONTH 3
üéØ –†–ï–ö–û–ú–ï–ù–î–ê–¶–ò–ò –ü–û –ü–†–ò–û–†–ò–¢–ï–¢–ê–ú
WEEK 1 (Priority 1 - –û–ë–Ø–ó–ê–¢–ï–õ–¨–ù–û)
text
Effort: 2-3 –¥–Ω—è –¥–ª—è –æ–¥–Ω–æ–≥–æ —Ä–∞–∑—Ä–∞–±–æ—Ç—á–∏–∫–∞

[ ] Fix #1: HTTP connection leak (30 min)
[ ] Fix #2: Race condition (15 min)
[ ] Fix #3: Memory leak (2h)
[ ] Fix #4: Tool timeout (1h)
[ ] Fix #5: Graceful shutdown (1h)
[ ] Add -race tests (1h)
–ü–æ—Å–ª–µ —ç—Ç–æ–≥–æ: Production-ready —Å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥–æ–º

WEEK 2-3 (Priority 2 - –í–ê–ñ–ù–û)
text
[ ] Structured logging
[ ] Metrics collection
[ ] Health check endpoints
[ ] Test coverage > 75%
WEEK 4+ (Priority 3 - –ü–õ–ê–ù–ò–†–û–í–ê–¢–¨)
text
[ ] Package hierarchy refactor
[ ] DI –∫–æ–Ω—Ç–µ–π–Ω–µ—Ä
[ ] Plugin system
[ ] Type-safe state manager
üìã SUMMARY TABLE
–ö–∞—Ç–µ–≥–æ—Ä–∏—è	–ù–∞–π–¥–µ–Ω–æ	–ö—Ä–∏—Ç–∏—á–Ω–æ—Å—Ç—å	Effort
Memory leaks	1	üî¥ HIGH	M
Race conditions	2	üî¥ HIGH	S
Error handling	2	üü° MEDIUM	M
Architecture	5	üü† MEDIUM	L
Code quality	4	üü° MEDIUM	S
TOTAL	14	-	-
–ó–ê–ö–õ–Æ–ß–ï–ù–ò–ï
–ü—Ä–æ–µ–∫—Ç –≥–æ—Ç–æ–≤ –Ω–∞ 70% –¥–ª—è production:

‚úÖ –ü—Ä–∞–≤–∏–ª—å–Ω–∞—è –∞—Ä—Ö–∏—Ç–µ–∫—Ç—É—Ä–∞ –ø–∞—Ç—Ç–µ—Ä–Ω–æ–≤

‚ùå –ö—Ä–∏—Ç–∏—á–µ—Å–∫–∏–µ –æ—à–∏–±–∫–∏ –∫–æ–Ω–∫—É—Ä–µ–Ω—Ç–Ω–æ—Å—Ç–∏/–ø–∞–º—è—Ç–∏

‚ùå –û—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç graceful shutdown

‚ö†Ô∏è –ù—É–∂–Ω–æ —É–ª—É—á—à–∏—Ç—å –º–æ–Ω–∏—Ç–æ—Ä–∏–Ω–≥

–ü–æ—Å–ª–µ Priority 1 fixes (1 –Ω–µ–¥–µ–ª—è): 8/10 production-ready
–ü–æ—Å–ª–µ full refactor (2 –º–µ—Å—è—Ü–∞): 9/10 enterprise-ready

code_fixes.md
–ø–æ–∫–∞–∂–∏ —Ñ–∞–π–ª code_fixes.md
Code Fixes - Poncho AI
Fix #1: HTTP Connection Leak –≤ WB Client
‚ùå BEFORE (–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ)
go
// pkg/wb/client.go - doRequest
func (c *Client) doRequest(
    ctx context.Context, 
    toolID string, 
    rateLimit int, 
    burst int, 
    req httpRequest, 
    dest interface{},
) error {
    limiter := c.getOrCreateLimiter(toolID, rateLimit, burst)
    
    var lastErr error
    for i := 0; i < c.retryAttempts; i++ {
        if err := limiter.Wait(ctx); err != nil {
            return fmt.Errorf("rate limiter wait: %w", err)
        }
        
        httpReq, err := http.NewRequestWithContext(ctx, req.method, req.url, req.body)
        if err != nil {
            return err
        }
        
        httpReq.Header.Set("Authorization", c.apiKey)
        httpReq.Header.Set("Content-Type", "application/json")
        httpReq.Header.Set("Accept", "application/json")
        
        resp, err := c.httpClient.Do(httpReq)
        // ‚ùå –ü–†–û–ë–õ–ï–ú–ê: –ï—Å–ª–∏ err != nil, resp –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ nil (partial response)
        // –∏ —Ç–µ–ª–æ –Ω–µ –∑–∞–∫—Ä–æ–µ—Ç—Å—è, —É—Ç–µ—á–∫–∞ —Ñ–∞–π–ª–æ–≤–æ–≥–æ –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–∞
        if err != nil {
            lastErr = err
            continue
        }
        
        defer resp.Body.Close()
        body, _ := io.ReadAll(resp.Body)
        
        if resp.StatusCode == http.StatusTooManyRequests {
            // Retry...
            continue
        }
        
        if resp.StatusCode != http.StatusOK {
            return fmt.Errorf("api error: %d %s", resp.StatusCode, string(body))
        }
        
        return json.Unmarshal(body, dest)
    }
    
    return fmt.Errorf("max retries exceeded: %w", lastErr)
}
‚úÖ AFTER (–ü—Ä–∞–≤–∏–ª—å–Ω–æ)
go
// pkg/wb/client.go - doRequest (FIXED)
func (c *Client) doRequest(
    ctx context.Context,
    toolID string,
    rateLimit int,
    burst int,
    req httpRequest,
    dest interface{},
) error {
    limiter := c.getOrCreateLimiter(toolID, rateLimit, burst)
    
    var lastErr error
    for i := 0; i < c.retryAttempts; i++ {
        if err := limiter.Wait(ctx); err != nil {
            return fmt.Errorf("rate limiter wait: %w", err)
        }
        
        httpReq, err := http.NewRequestWithContext(ctx, req.method, req.url, req.body)
        if err != nil {
            return err
        }
        
        httpReq.Header.Set("Authorization", c.apiKey)
        httpReq.Header.Set("Content-Type", "application/json")
        httpReq.Header.Set("Accept", "application/json")
        
        resp, err := c.httpClient.Do(httpReq)
        // ‚úÖ FIX: –í—Å–µ–≥–¥–∞ –∑–∞–∫—Ä—ã–≤–∞–µ–º —Ç–µ–ª–æ, –¥–∞–∂–µ –µ—Å–ª–∏ err != nil
        if resp != nil {
            defer resp.Body.Close()
        }
        
        if err != nil {
            lastErr = err
            continue
        }
        
        body, readErr := io.ReadAll(resp.Body)
        if readErr != nil {
            lastErr = fmt.Errorf("read response body: %w", readErr)
            continue
        }
        
        if resp.StatusCode == http.StatusTooManyRequests {
            // Retry...
            continue
        }
        
        if resp.StatusCode != http.StatusOK {
            lastErr = fmt.Errorf("api error: %d %s", resp.StatusCode, string(body))
            continue
        }
        
        if err := json.Unmarshal(body, dest); err != nil {
            lastErr = fmt.Errorf("unmarshal response: %w", err)
            continue
        }
        
        return nil // Success
    }
    
    return fmt.Errorf("max retries exceeded (last error: %w)", lastErr)
}
–ö–ª—é—á–µ–≤–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ:

go
// ‚ùå –ë–´–õ–û:
resp, err := c.httpClient.Do(httpReq)
if err != nil {
    continue  // resp –º–æ–∂–µ—Ç –±—ã—Ç—å –Ω–µ nil!
}
defer resp.Body.Close()

// ‚úÖ –°–¢–ê–õ–û:
resp, err := c.httpClient.Do(httpReq)
if resp != nil {
    defer resp.Body.Close()  // –ó–∞–∫—Ä—ã–≤–∞–µ–º –î–û –ø—Ä–æ–≤–µ—Ä–∫–∏ err
}
if err != nil {
    continue
}
–ü–æ—á–µ–º—É —ç—Ç–æ –≤–∞–∂–Ω–æ:

HTTP –∫–ª–∏–µ–Ω—Ç –º–æ–∂–µ—Ç –≤–µ—Ä–Ω—É—Ç—å –æ—à–∏–±–∫—É –ò partial response

–ï—Å–ª–∏ –Ω–µ –∑–∞–∫—Ä—ã—Ç—å Body, —Ñ–∞–π–ª–æ–≤—ã–π –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä –æ—Å—Ç–∞–Ω–µ—Ç—Å—è –æ—Ç–∫—Ä—ã—Ç—ã–º

–ü–æ—Å–ª–µ ~1024 —Ç–∞–∫–∏—Ö —É—Ç–µ—á–µ–∫ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ –∑–∞–≤–∏—Å–Ω–µ—Ç –Ω–∞ too many open files

–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ:

go
func TestHTTPConnectionNotLeaked(t *testing.T) {
    client := &Client{
        httpClient: &http.Client{
            Transport: &errorTransport{},  // Mock that returns error + partial response
        },
    }
    
    // –í—ã–∑–æ–≤–µ–º –º–Ω–æ–≥–æ —Ä–∞–∑
    for i := 0; i < 1000; i++ {
        client.doRequest(ctx, "tool", 10, 1, req, &dest)
    }
    
    // –ü—Ä–æ–≤–µ—Ä–∏–º, —á—Ç–æ —Ñ–∞–π–ª–æ–≤—ã—Ö –¥–µ—Å–∫—Ä–∏–ø—Ç–æ—Ä–æ–≤ –Ω–µ —Ä–∞—Å—Ç–µ—Ç
    assert.Less(t, countOpenFDs(), 100)
}
Fix #2: Race Condition –≤ Agent.SetEmitter
‚ùå BEFORE (–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ)
go
// pkg/agent/agent.go
func (c *Client) SetEmitter(emitter events.Emitter) {
    c.emitterMu.Lock()
    defer c.emitterMu.Unlock()
    c.emitter = emitter
    
    // ‚ùå RACE CONDITION: c.reactCycle –º–æ–∂–µ—Ç –±—ã—Ç—å –∏–∑–º–µ–Ω–µ–Ω –≤ –¥—Ä—É–≥–æ–º goroutine
    // –º–µ–∂–¥—É —Å–Ω—è—Ç–∏–µ–º –º—å—é—Ç–µ–∫—Å–∞ –∏ –≤—ã–∑–æ–≤–æ–º SetEmitter
    if c.reactCycle != nil {
        c.reactCycle.SetEmitter(emitter)
    }
}
‚úÖ AFTER (–ü—Ä–∞–≤–∏–ª—å–Ω–æ)
go
// pkg/agent/agent.go (FIXED)
func (c *Client) SetEmitter(emitter events.Emitter) {
    c.emitterMu.Lock()
    // ‚úÖ FIX: –î–µ–ª–∞–µ–º snapshot reactCycle –î–û —Ä–∞–∑–≤–æ–¥–∞ –º—å—é—Ç–µ–∫—Å–∞
    reactCycle := c.reactCycle
    c.emitter = emitter
    c.emitterMu.Unlock()
    
    // –ò—Å–ø–æ–ª—å–∑—É–µ–º snapshot –≤–Ω–µ –∫—Ä–∏—Ç–∏—á–µ—Å–∫–æ–π —Å–µ–∫—Ü–∏–∏
    // reactCycle –Ω–µ –º–æ–∂–µ—Ç –∏–∑–º–µ–Ω–∏—Ç—å—Å—è, –ø–æ—Ç–æ–º—É —á—Ç–æ —É –Ω–∞—Å –µ—Å—Ç—å –µ–≥–æ –∫–æ–ø–∏—è
    if reactCycle != nil {
        reactCycle.SetEmitter(emitter)
    }
}
–ö–ª—é—á–µ–≤–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ:

go
// ‚ùå –ë–´–õ–û:
c.emitterMu.Lock()
defer c.emitterMu.Unlock()
c.emitter = emitter
if c.reactCycle != nil {  // ‚Üê –ú–æ–∂–µ—Ç –∏–∑–º–µ–Ω–∏—Ç—å—Å—è –º–µ–∂–¥—É Lock –∏ –ø—Ä–æ–≤–µ—Ä–∫–æ–π!
    c.reactCycle.SetEmitter(emitter)
}

// ‚úÖ –°–¢–ê–õ–û:
c.emitterMu.Lock()
reactCycle := c.reactCycle  // ‚Üê Snapshot –î–û —Ä–∞–∑–≤–æ—Ä–∞—á–∏–≤–∞–Ω–∏—è –º—å—é—Ç–µ–∫—Å–∞
c.emitter = emitter
c.emitterMu.Unlock()

if reactCycle != nil {  // ‚Üê –ë–µ–∑–æ–ø–∞—Å–Ω–æ, —ç—Ç–æ –ª–æ–∫–∞–ª—å–Ω–∞—è –ø–µ—Ä–µ–º–µ–Ω–Ω–∞—è
    reactCycle.SetEmitter(emitter)
}
–ü–æ—á–µ–º—É —ç—Ç–æ –≤–∞–∂–Ω–æ:

–î—Ä—É–≥–æ–π goroutine –º–æ–∂–µ—Ç –≤—ã–∑–≤–∞—Ç—å –º–µ—Ç–æ–¥, –∫–æ—Ç–æ—Ä—ã–π –º–µ–Ω—è–µ—Ç c.reactCycle

–ï—Å–ª–∏ –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –∏ –≤—ã–∑–≤–∞—Ç—å —Å –∏–Ω—Ç–µ—Ä–≤–∞–ª–æ–º, —Ç–æ –º–æ–∂–µ—Ç –±—ã—Ç—å nil pointer

–°–Ω–∏–º–æ–∫ (snapshot) —Ä–µ—à–∞–µ—Ç –ø—Ä–æ–±–ª–µ–º—É

–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ:

go
func TestSetEmitterRaceFree(t *testing.T) {
    client := &Client{
        reactCycle: &mockReactCycle{},
    }
    
    var wg sync.WaitGroup
    
    // Goroutine 1: –º–µ–Ω—è–µ—Ç emitter
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            client.SetEmitter(events.NewChanEmitter(10))
        }()
    }
    
    // Goroutine 2: –º–µ–Ω—è–µ—Ç reactCycle
    for i := 0; i < 100; i++ {
        wg.Add(1)
        go func() {
            defer wg.Done()
            client.reactCycle = &mockReactCycle{}
        }()
    }
    
    wg.Wait()
    // –ù–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –ø–∞–Ω–∏–∫ –∏–ª–∏ race condition
}
Fix #3: Memory Leak –≤ Debug Recorder
‚ùå BEFORE (–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ)
go
// pkg/debug/recorder.go
type Recorder struct {
    mu            sync.Mutex
    config        RecorderConfig
    log           DebugLog
    currentIteration *Iteration
    visitedTools  map[string]struct{}
    errors        []string
}

func (r *Recorder) EndIteration() {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    // ‚ùå –ü–†–û–ë–õ–ï–ú–ê: r.log.Iterations —Ä–∞—Å—Ç–µ—Ç –±–µ–∑ –æ–≥—Ä–∞–Ω–∏—á–µ–Ω–∏–π
    // –í long-running –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏ —ç—Ç–æ –º–æ–∂–µ—Ç –ø—Ä–∏–≤–µ—Å—Ç–∏ –∫ OOM
    if r.currentIteration != nil {
        r.log.Iterations = append(r.log.Iterations, r.currentIteration)
        r.currentIteration = nil
    }
}

func (r *Recorder) Finalize(finalResult string, duration time.Duration) (string, error) {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    r.log.FinalResult = finalResult
    r.log.Duration = duration.Milliseconds()
    r.log.Summary = r.buildSummary(duration)
    
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º –í–°–ï –∏—Ç–µ—Ä–∞—Ü–∏–∏ –≤ JSON —Ñ–∞–π–ª
    // –ï—Å–ª–∏ –∏—Ç–µ—Ä–∞—Ü–∏–π 1000+, —Ñ–∞–π–ª –º–æ–∂–µ—Ç –±—ã—Ç—å –≥–∏–≥–∞–±–∞–π—Ç—ã
    data, err := json.MarshalIndent(r.log, "", "  ")
    if err != nil {
        return "", fmt.Errorf("failed to marshal debug log: %w", err)
    }
    
    filePath := r.getFilePath()
    if err := os.WriteFile(filePath, data, 0644); err != nil {
        return "", fmt.Errorf("failed to write debug log: %w", err)
    }
    
    return filePath, nil
}
‚úÖ AFTER (–ü—Ä–∞–≤–∏–ª—å–Ω–æ)
go
// pkg/debug/recorder.go (FIXED)
const MaxIterationsInMemory = 100  // –û–≥—Ä–∞–Ω–∏—á–∏–≤–∞–µ–º –≤ –ø–∞–º—è—Ç–∏

type Recorder struct {
    mu                  sync.Mutex
    config              RecorderConfig
    log                 DebugLog
    currentIteration    *Iteration
    visitedTools        map[string]struct{}
    errors              []string
    savedIterationCount int64  // –°—á–µ—Ç—á–∏–∫ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–Ω—ã—Ö –∏—Ç–µ—Ä–∞—Ü–∏–π
    archivedPath        string // –ü—É—Ç—å –∫ –∞—Ä—Ö–∏–≤—É —Å—Ç–∞—Ä—ã—Ö –∏—Ç–µ—Ä–∞—Ü–∏–π
}

func NewRecorder(cfg RecorderConfig) (*Recorder, error) {
    if cfg.LogsDir == "" {
        if execPath, err := os.Executable(); err == nil {
            cfg.LogsDir = filepath.Join(filepath.Dir(execPath), "debuglogs")
        } else {
            cfg.LogsDir = ".debuglogs"
        }
    }
    
    if err := os.MkdirAll(cfg.LogsDir, 0755); err != nil {
        return nil, fmt.Errorf("failed to create logs directory: %w", err)
    }
    
    RunID := fmt.Sprintf("debug-%s", time.Now().Format("20060102150405"))
    
    // ‚úÖ FIX: –°–æ–∑–¥–∞–µ–º –∞—Ä—Ö–∏–≤–Ω—ã–π —Ñ–∞–π–ª –¥–ª—è —Å—Ç–∞—Ä—ã—Ö –∏—Ç–µ—Ä–∞—Ü–∏–π
    archivedPath := filepath.Join(cfg.LogsDir, fmt.Sprintf("%s-archived.jsonl", RunID))
    
    return &Recorder{
        config:       cfg,
        log:          DebugLog{RunID: RunID, Timestamp: time.Now()},
        visitedTools: make(map[string]struct{}),
        errors:       make([]string, 0),
        archivedPath: archivedPath,
    }, nil
}

func (r *Recorder) EndIteration() {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    if r.currentIteration != nil {
        r.log.Iterations = append(r.log.Iterations, r.currentIteration)
        r.currentIteration = nil
        
        // ‚úÖ FIX: –ï—Å–ª–∏ —Å–ª–∏—à–∫–æ–º –º–Ω–æ–≥–æ –∏—Ç–µ—Ä–∞—Ü–∏–π –≤ –ø–∞–º—è—Ç–∏, –∞—Ä—Ö–∏–≤–∏—Ä—É–µ–º —Å—Ç–∞—Ä—ã–µ
        if len(r.log.Iterations) > MaxIterationsInMemory {
            r.rotateIterations()
        }
    }
}

// ‚úÖ NEW: –ú–µ—Ç–æ–¥ –¥–ª—è —Ä–æ—Ç–∞—Ü–∏–∏ –∏—Ç–µ—Ä–∞—Ü–∏–π
func (r *Recorder) rotateIterations() {
    // –°–æ—Ö—Ä–∞–Ω—è–µ–º —Å—Ç–∞—Ä—ã–µ –∏—Ç–µ—Ä–∞—Ü–∏–∏ –≤ JSONL (–ø–æ –æ–¥–Ω–æ–π –Ω–∞ —Å—Ç—Ä–æ–∫—É)
    // –≠—Ç–æ —ç–∫–æ–Ω–æ–º–Ω–µ–µ, —á–µ–º –ø–æ–ª–Ω—ã–π JSON –º–∞—Å—Å–∏–≤
    if len(r.log.Iterations) > MaxIterationsInMemory*2 {
        archiveCount := len(r.log.Iterations) - MaxIterationsInMemory
        
        archiveFile, err := os.OpenFile(
            r.archivedPath,
            os.O_CREATE|os.O_WRONLY|os.O_APPEND,
            0644,
        )
        if err != nil {
            utils.Warn("Failed to open archive file", "error", err)
            return
        }
        defer archiveFile.Close()
        
        encoder := json.NewEncoder(archiveFile)
        for i := 0; i < archiveCount; i++ {
            if err := encoder.Encode(r.log.Iterations[i]); err != nil {
                utils.Warn("Failed to archive iteration", "error", err)
            }
            r.savedIterationCount++
        }
        
        // –û—Å—Ç–∞–≤–ª—è–µ–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ –∏—Ç–µ—Ä–∞—Ü–∏–∏ –≤ –ø–∞–º—è—Ç–∏
        r.log.Iterations = r.log.Iterations[archiveCount:]
    }
}

func (r *Recorder) Finalize(finalResult string, duration time.Duration) (string, error) {
    r.mu.Lock()
    defer r.mu.Unlock()
    
    r.log.FinalResult = finalResult
    r.log.Duration = duration.Milliseconds()
    r.log.Summary = r.buildSummary(duration)
    
    // ‚úÖ FIX: –°–æ—Ö—Ä–∞–Ω—è–µ–º —Ç–æ–ª—å–∫–æ –ø–æ—Å–ª–µ–¥–Ω–∏–µ –∏—Ç–µ—Ä–∞—Ü–∏–∏ –≤ –ø–∞–º—è—Ç–∏
    // –û—Å—Ç–∞–ª—å–Ω—ã–µ —É–∂–µ –≤ –∞—Ä—Ö–∏–≤–µ
    data, err := json.MarshalIndent(r.log, "", "  ")
    if err != nil {
        return "", fmt.Errorf("failed to marshal debug log: %w", err)
    }
    
    filePath := r.getFilePath()
    if err := os.WriteFile(filePath, data, 0644); err != nil {
        return "", fmt.Errorf("failed to write debug log: %w", err)
    }
    
    // –ï—Å–ª–∏ –±—ã–ª –∞—Ä—Ö–∏–≤, –¥–æ–±–∞–≤–∏–º –µ–≥–æ –¥–æ —Ñ–∏–Ω–∞–ª—å–Ω–æ–≥–æ —Ñ–∞–π–ª–∞
    if r.savedIterationCount > 0 {
        utils.Info("Debug iterations archived", "count", r.savedIterationCount, "archive", r.archivedPath)
    }
    
    return filePath, nil
}
–ö–ª—é—á–µ–≤–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ:

go
// ‚ùå –ë–´–õ–û:
// –í—Å–µ –∏—Ç–µ—Ä–∞—Ü–∏–∏ –∫–æ–ø—è—Ç—Å—è –≤ –ø–∞–º—è—Ç–∏ –Ω–∞–≤–µ—á–Ω–æ
r.log.Iterations = append(r.log.Iterations, r.currentIteration)

// ‚úÖ –°–¢–ê–õ–û:
r.log.Iterations = append(r.log.Iterations, r.currentIteration)
if len(r.log.Iterations) > MaxIterationsInMemory {
    r.rotateIterations()  // –ê—Ä—Ö–∏–≤–∏—Ä—É–µ–º —Å—Ç–∞—Ä—ã–µ –Ω–∞ –¥–∏—Å–∫
}
–ü–æ—á–µ–º—É —ç—Ç–æ –≤–∞–∂–Ω–æ:

Debug –ª–æ–≥–≥–µ—Ä –º–æ–∂–µ—Ç —Ä–∞–±–æ—Ç–∞—Ç—å —á–∞—Å–∞–º–∏/–¥–Ω—è–º–∏

–ö–∞–∂–¥–∞—è –∏—Ç–µ—Ä–∞—Ü–∏—è –º–æ–∂–µ—Ç –±—ã—Ç—å 10-100KB

10000 –∏—Ç–µ—Ä–∞—Ü–∏–π = 100-1000 MB –≤ –ø–∞–º—è—Ç–∏

–° —Ä–æ—Ç–∞—Ü–∏–µ–π: –º–∞–∫—Å–∏–º—É–º 100 –∏—Ç–µ—Ä–∞—Ü–∏–π = ~10 MB

–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ:

go
func TestMemoryLeakRecorder(t *testing.T) {
    recorder, _ := NewRecorder(RecorderConfig{LogsDir: t.TempDir()})
    
    // –ó–∞–ø—É—Å–∫–∞–µ–º 10000 –∏—Ç–µ—Ä–∞—Ü–∏–π
    for i := 0; i < 10000; i++ {
        recorder.StartIteration(i)
        recorder.EndIteration()
    }
    
    // –ü—Ä–æ–≤–µ—Ä—è–µ–º, —á—Ç–æ –≤ –ø–∞–º—è—Ç–∏ –Ω–µ –±–æ–ª–µ–µ 100 –∏—Ç–µ—Ä–∞—Ü–∏–π
    assert.Less(t, len(recorder.log.Iterations), 150)
}
Fix #4: Context Timeout –¥–ª—è Tools
‚ùå BEFORE (–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ)
go
// pkg/chain/toolstep.go
func (s *ToolExecutionStep) executeToolCall(
    ctx context.Context,
    tc llm.ToolCall,
    chainCtx ChainContext,
) (ToolResult, error) {
    start := time.Now()
    result := ToolResult{Name: tc.Name, Args: tc.Args}
    
    tool, err := s.registry.Get(tc.Name)
    if err != nil {
        result.Success = false
        result.Error = err
        return result, err
    }
    
    cleanArgs := utils.CleanJsonBlock(tc.Args)
    
    // ‚ùå –ü–†–û–ë–õ–ï–ú–ê: –ï—Å–ª–∏ tool.Execute –∑–∞–≤–∏—Å–∞–µ—Ç, –Ω–µ—Ç timeout
    // –í–µ—Å—å –∞–≥–µ–Ω—Ç –∑–∞–≤–∏—Å–Ω–µ—Ç –Ω–∞–≤–µ—á–Ω–æ
    execResult, execErr := tool.Execute(ctx, cleanArgs)
    duration := time.Since(start).Milliseconds()
    
    if execErr != nil {
        result.Success = false
        result.Error = execErr
        result.Result = fmt.Sprintf("Error: %v", execErr)
    } else {
        result.Success = true
        result.Result = execResult
    }
    
    result.Duration = duration
    return result, nil
}
‚úÖ AFTER (–ü—Ä–∞–≤–∏–ª—å–Ω–æ)
go
// pkg/chain/toolstep.go (FIXED)
type ToolExecutionStep struct {
    registry           tools.Registry
    promptLoader       PromptLoader
    debugRecorder      ChainDebugRecorder
    startTime          time.Time
    toolResults        []ToolResult
    
    // ‚úÖ NEW: –ö–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—è timeouts
    defaultToolTimeout time.Duration
    toolTimeouts       map[string]time.Duration  // –ü–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª—è–µ–º—ã–µ timeouts
}

func NewToolExecutionStep(
    registry tools.Registry,
    promptLoader PromptLoader,
    defaultTimeout time.Duration,
) *ToolExecutionStep {
    return &ToolExecutionStep{
        registry:           registry,
        promptLoader:       promptLoader,
        defaultToolTimeout: defaultTimeout,
        toolTimeouts:       make(map[string]time.Duration),
    }
}

// ‚úÖ NEW: –ú–µ—Ç–æ–¥ –¥–ª—è –ø–µ—Ä–µ–æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è timeout –¥–ª—è –∫–æ–Ω–∫—Ä–µ—Ç–Ω–æ–≥–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
func (s *ToolExecutionStep) SetToolTimeout(toolName string, timeout time.Duration) {
    s.toolTimeouts[toolName] = timeout
}

func (s *ToolExecutionStep) executeToolCall(
    ctx context.Context,
    tc llm.ToolCall,
    chainCtx ChainContext,
) (ToolResult, error) {
    start := time.Now()
    result := ToolResult{Name: tc.Name, Args: tc.Args}
    
    tool, err := s.registry.Get(tc.Name)
    if err != nil {
        result.Success = false
        result.Error = err
        return result, err
    }
    
    cleanArgs := utils.CleanJsonBlock(tc.Args)
    
    // ‚úÖ FIX: –û–ø—Ä–µ–¥–µ–ª—è–µ–º timeout –¥–ª—è —ç—Ç–æ–≥–æ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
    timeout := s.defaultToolTimeout
    if customTimeout, exists := s.toolTimeouts[tc.Name]; exists {
        timeout = customTimeout
    }
    
    // ‚úÖ FIX: –°–æ–∑–¥–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç —Å timeout
    toolCtx, cancel := context.WithTimeout(ctx, timeout)
    defer cancel()
    
    // Channel –¥–ª—è —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è
    type execResult struct {
        output string
        err    error
    }
    resultChan := make(chan execResult, 1)
    
    // –í—ã–ø–æ–ª–Ω—è–µ–º tool –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–º goroutine
    // –ß—Ç–æ–±—ã –º–æ–∂–Ω–æ –±—ã–ª–æ –æ—Ç–º–µ–Ω–∏—Ç—å —á–µ—Ä–µ–∑ context
    go func() {
        execOutput, execErr := tool.Execute(toolCtx, cleanArgs)
        resultChan <- execResult{execOutput, execErr}
    }()
    
    // –ñ–¥–µ–º —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –∏–ª–∏ timeout
    select {
    case <-toolCtx.Done():
        // ‚úÖ FIX: Tool –ø—Ä–µ–≤—ã—à–∏–ª timeout
        result.Success = false
        result.Duration = time.Since(start).Milliseconds()
        
        if toolCtx.Err() == context.DeadlineExceeded {
            result.Error = fmt.Errorf("tool execution timeout after %v", timeout)
            result.Result = fmt.Sprintf(
                "Tool %q exceeded timeout of %v. "+
                    "Either the tool is stuck or the API response is slow.",
                tc.Name, timeout,
            )
        } else {
            result.Error = fmt.Errorf("tool execution cancelled: %w", toolCtx.Err())
            result.Result = "Tool execution was cancelled"
        }
        
        // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –≤ debug –ª–æ–≥–≥–µ—Ä
        if s.debugRecorder != nil && s.debugRecorder.Enabled {
            s.debugRecorder.RecordToolExecution(
                tc.Name, cleanArgs,
                result.Result,
                result.Duration,
                result.Success,
            )
        }
        
        return result, result.Error
        
    case res := <-resultChan:
        // Tool –∑–∞–≤–µ—Ä—à–∏–ª—Å—è –≤ –ø—Ä–µ–¥–µ–ª–∞—Ö timeout
        duration := time.Since(start).Milliseconds()
        
        if res.err != nil {
            result.Success = false
            result.Error = res.err
            result.Result = fmt.Sprintf("Error: %v", res.err)
        } else {
            result.Success = true
            result.Result = res.output
        }
        
        result.Duration = duration
        
        // –ó–∞–ø–∏—Å—ã–≤–∞–µ–º –≤ debug –ª–æ–≥–≥–µ—Ä
        if s.debugRecorder != nil && s.debugRecorder.Enabled {
            s.debugRecorder.RecordToolExecution(
                tc.Name, cleanArgs,
                result.Result,
                result.Duration,
                result.Success,
            )
        }
        
        return result, nil
    }
}
–ö–ª—é—á–µ–≤–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ:

go
// ‚ùå –ë–´–õ–û:
execResult, execErr := tool.Execute(ctx, cleanArgs)

// ‚úÖ –°–¢–ê–õ–û:
toolCtx, cancel := context.WithTimeout(ctx, 30*time.Second)
defer cancel()

select {
case <-toolCtx.Done():
    return ToolResult{Error: "timeout"}
case res := <-resultChan:
    return res
}
–ü–æ—á–µ–º—É —ç—Ç–æ –≤–∞–∂–Ω–æ:

API –º–æ–∂–µ—Ç –±—ã—Ç—å –º–µ–¥–ª–µ–Ω–Ω—ã–º –∏–ª–∏ –∑–∞–≤–∏—Å–Ω—É—Ç—å

–ë–µ–∑ timeout –≤–µ—Å—å –∞–≥–µ–Ω—Ç –∑–∞–º–æ—Ä–æ–∑–∏—Ç—Å—è

–° timeout –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –ø–æ–ª—É—á–∏—Ç —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–± –æ—à–∏–±–∫–µ –∑–∞ 30 —Å–µ–∫—É–Ω–¥

–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ:

go
func TestToolTimeoutProtection(t *testing.T) {
    slowTool := &mockTool{
        executeFn: func(ctx context.Context, args string) (string, error) {
            <-time.After(10 * time.Second)  // –ó–∞–≤–∏—Å–∞–µ—Ç –Ω–∞ 10 —Å–µ–∫—É–Ω–¥
            return "result", nil
        },
    }
    
    step := NewToolExecutionStep(registry, loader, 1*time.Second)
    result, _ := step.executeToolCall(context.Background(), slowTool, emptyInput)
    
    // –î–æ–ª–∂–Ω–æ –≤–µ—Ä–Ω—É—Ç—å—Å—è –∑–∞ ~1 —Å–µ–∫—É–Ω–¥—É, –∞ –Ω–µ 10
    assert.False(t, result.Success)
    assert.Contains(t, result.Result, "timeout")
    assert.Less(t, result.Duration, int64(2000))  // < 2 sec
}
Fix #5: Graceful Shutdown
‚ùå BEFORE (–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ)
go
// cmd/main.go
func main() {
    ctx := context.Background()
    
    client, err := agent.New(ctx, agent.Config{
        ConfigPath: "config.yaml",
    })
    if err != nil {
        log.Fatal(err)
    }
    
    result, err := client.Run(ctx, "Find products under 1000 rubles")
    if err != nil {
        log.Fatal(err)
    }
    
    fmt.Println(result)
    
    // ‚ùå –ü–†–û–ë–õ–ï–ú–ê: –ï—Å–ª–∏ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å –Ω–∞–∂–º–µ—Ç Ctrl+C, –ª–æ–≥–∏ –Ω–µ —Å–æ—Ö—Ä–∞–Ω—è—Ç—Å—è
    // DebugRecorder —Ñ–∞–π–ª—ã –º–æ–≥—É—Ç –±—ã—Ç—å –ø–æ—Ç–µ—Ä—è–Ω—ã
    // utils.Close() –Ω–µ –±—É–¥–µ—Ç –≤—ã–∑–≤–∞–Ω
}
‚úÖ AFTER (–ü—Ä–∞–≤–∏–ª—å–Ω–æ)
go
// cmd/main.go (FIXED)
package main

import (
    "context"
    "fmt"
    "log"
    "os"
    "os/signal"
    "syscall"
    
    "github.com/ilkoid/poncho-ai/pkg/agent"
    "github.com/ilkoid/poncho-ai/pkg/utils"
)

func main() {
    // ‚úÖ FIX: –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∏—Ä—É–µ–º –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ
    if err := utils.InitLogger(); err != nil {
        log.Fatalf("Failed to initialize logger: %v", err)
    }
    defer utils.Close()  // –í—Å–µ–≥–¥–∞ –∑–∞–∫—Ä—ã–≤–∞–µ–º –ª–æ–≥–∏ –≤ –∫–æ–Ω—Ü–µ
    
    // ‚úÖ FIX: –°–æ–∑–¥–∞–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç, –∫–æ—Ç–æ—Ä—ã–π –º–æ–∂–Ω–æ –æ—Ç–º–µ–Ω–∏—Ç—å
    ctx, cancel := context.WithCancel(context.Background())
    defer cancel()
    
    // ‚úÖ FIX: –û–±—Ä–∞–±–æ—Ç—á–∏–∫ OS —Å–∏–≥–Ω–∞–ª–æ–≤
    sigChan := make(chan os.Signal, 1)
    signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM)
    
    go func() {
        sig := <-sigChan
        utils.Info("Received signal, shutting down gracefully",
            "signal", sig.String(),
        )
        cancel()  // –û—Ç–º–µ–Ω—è–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è –≤—Å–µ—Ö –æ–ø–µ—Ä–∞—Ü–∏–π
    }()
    
    // –ò–Ω–∏—Ü–∏–∞–ª–∏–∑–∞—Ü–∏—è –∞–≥–µ–Ω—Ç–∞
    utils.Info("Starting Poncho AI agent")
    client, err := agent.New(ctx, agent.Config{
        ConfigPath: "config.yaml",
    })
    if err != nil {
        utils.Error("Failed to initialize agent", "error", err)
        os.Exit(1)
    }
    
    // –ü–æ–ª—É—á–∞–µ–º query –æ—Ç –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è –∏–ª–∏ –∏–∑ —Ñ–ª–∞–≥–∞
    query := "Find products under 1000 rubles"
    if len(os.Args) > 1 {
        query = os.Args[1]
    }
    
    // ‚úÖ FIX: –ò—Å–ø–æ–ª—å–∑—É–µ–º –∫–æ–Ω—Ç–µ–∫—Å—Ç –¥–ª—è –æ–ø–µ—Ä–∞—Ü–∏–∏
    utils.Info("Running query", "query", query)
    result, err := client.Run(ctx, query)
    
    // –û–±—Ä–∞–±–æ—Ç–∫–∞ —Ä–∞–∑–ª–∏—á–Ω—ã—Ö —Ç–∏–ø–æ–≤ –æ—à–∏–±–æ–∫
    if err != nil {
        if ctx.Err() == context.Canceled {
            utils.Info("Operation cancelled by user")
            os.Exit(130)  // Standard exit code for SIGINT
        } else if ctx.Err() == context.DeadlineExceeded {
            utils.Error("Operation exceeded timeout", "error", err)
            os.Exit(1)
        } else {
            utils.Error("Operation failed", "error", err)
            os.Exit(1)
        }
    }
    
    // –£—Å–ø–µ—à–Ω–æ–µ –∑–∞–≤–µ—Ä—à–µ–Ω–∏–µ
    utils.Info("Query completed successfully")
    fmt.Println(result)
    os.Exit(0)
}

// ‚úÖ OPTIONAL: Helper –¥–ª—è –±–æ–ª–µ–µ —Å–ª–æ–∂–Ω–æ–≥–æ shutdown
func setupSignalHandler(ctx context.Context, cancel context.CancelFunc) {
    go func() {
        sigChan := make(chan os.Signal, 1)
        signal.Notify(sigChan, os.Interrupt, syscall.SIGTERM, syscall.SIGHUP)
        
        for sig := range sigChan {
            utils.Info("Received signal", "signal", sig.String())
            
            switch sig {
            case os.Interrupt, syscall.SIGTERM:
                utils.Info("Initiating graceful shutdown")
                cancel()
                
                // –î–∞–µ–º 30 —Å–µ–∫—É–Ω–¥ –Ω–∞ graceful shutdown
                go func() {
                    <-time.After(30 * time.Second)
                    utils.Error("Graceful shutdown timeout exceeded, forcing exit")
                    os.Exit(1)
                }()
                
            case syscall.SIGHUP:
                utils.Info("Reload signal received (not implemented)")
            }
        }
    }()
}
–ö–ª—é—á–µ–≤–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ:

go
// ‚ùå –ë–´–õ–û:
func main() {
    ctx := context.Background()  // –ù–µ–≤–æ–∑–º–æ–∂–Ω–æ –æ—Ç–º–µ–Ω–∏—Ç—å
    client.Run(ctx, query)
    // Ctrl+C ‚Üí –ø—Ä–æ—Ü–µ—Å—Å –ø—Ä–æ—Å—Ç–æ —É–±–∏–≤–∞–µ—Ç—Å—è
}

// ‚úÖ –°–¢–ê–õ–û:
func main() {
    ctx, cancel := context.WithCancel(context.Background())  // –û—Ç–º–µ–Ω—è–µ–º—ã–π –∫–æ–Ω—Ç–µ–∫—Å—Ç
    defer cancel()
    
    signal.Notify(sigChan, os.Interrupt)
    go func() {
        <-sigChan
        cancel()  // –û—Ç–º–µ–Ω—è–µ–º –ø—Ä–∏ Ctrl+C
    }()
    
    defer utils.Close()  // –í—Å–µ–≥–¥–∞ –∑–∞–∫—Ä—ã–≤–∞–µ–º —Ä–µ—Å—É—Ä—Å—ã
    client.Run(ctx, query)
}
–ü–æ—á–µ–º—É —ç—Ç–æ –≤–∞–∂–Ω–æ:

Ctrl+C –±–µ–∑ graceful shutdown = –ø–æ—Ç–µ—Ä—è –¥–∞–Ω–Ω—ã—Ö

–õ–æ–≥–∏ –Ω–µ —Å–æ—Ö—Ä–∞–Ω—è—é—Ç—Å—è

Debug recorder —Ñ–∞–π–ª—ã –æ—Å—Ç–∞—é—Ç—Å—è –Ω–µ–ø–æ–ª–Ω—ã–º–∏

–û—Ç–∫—Ä—ã—Ç—ã–µ —Å–æ–µ–¥–∏–Ω–µ–Ω–∏—è –Ω–µ –∑–∞–∫—Ä—ã–≤–∞—é—Ç—Å—è

–¢–µ—Å—Ç–∏—Ä–æ–≤–∞–Ω–∏–µ:

bash
# Terminal 1:
$ go run cmd/agent/main.go "Long query"

# Terminal 2 (—á–µ—Ä–µ–∑ 5 —Å–µ–∫—É–Ω–¥):
$ killall -INT main

# –û–∂–∏–¥–∞–µ–º:
# - –õ–æ–≥–∏—Ä–æ–≤–∞–Ω–∏–µ "Received signal"
# - Graceful cleanup
# - Exit code 130
Fix #6: Tools Setup Refactoring
‚ùå BEFORE (–ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω–æ)
go
// pkg/app/components.go - 200+ —Å—Ç—Ä–æ–∫ –≤ –æ–¥–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏
func SetupTools(state state.CoreState, wbClient wb.Client, visionLLM llm.Provider, cfg config.AppConfig) error {
    registry := state.GetToolsRegistry()
    
    var registered []string
    
    // WB Content API Tools
    if toolCfg, exists := getToolCfg("searchwbproducts"); exists && toolCfg.Enabled {
        if err := register("searchwbproducts", std.NewWbProductSearchTool(...)); err != nil {
            return err
        }
    }
    
    if toolCfg, exists := getToolCfg("getwbparentcategories"); exists && toolCfg.Enabled {
        if err := register("getwbparentcategories", std.NewWbParentCategoriesTool(...)); err != nil {
            return err
        }
    }
    
    // ... 80 similar if blocks ...
    
    if toolCfg, exists := getToolCfg("analyzearticleimagesbatch"); exists && toolCfg.Enabled {
        if visionLLM == nil {
            return fmt.Errorf("analyzearticleimagesbatch requires vision model")
        }
        // ...
    }
    
    return nil
}
‚úÖ AFTER (–ü—Ä–∞–≤–∏–ª—å–Ω–æ)
go
// pkg/app/tools_setup.go (NEW FILE)
package app

import (
    "fmt"
    "github.com/ilkoid/poncho-ai/pkg/config"
    "github.com/ilkoid/poncho-ai/pkg/llm"
    "github.com/ilkoid/poncho-ai/pkg/state"
    "github.com/ilkoid/poncho-ai/pkg/tools"
    "github.com/ilkoid/poncho-ai/pkg/toolsstd"
    "github.com/ilkoid/poncho-ai/pkg/wb"
)

// ‚úÖ NEW: Helper –¥–ª—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏–∏
type toolRegistrar struct {
    registry tools.Registry
    getToolCfg func(name string) (config.ToolConfig, bool)
}

func (tr *toolRegistrar) register(name string, tool tools.Tool) error {
    if err := tr.registry.Register(name, tool); err != nil {
        return fmt.Errorf("failed to register tool %s: %w", name, err)
    }
    return nil
}

// ‚úÖ NEW: –ì—Ä—É–ø–ø–æ–≤–∞—è —Ä–µ–≥–∏—Å—Ç—Ä–∞—Ü–∏—è –ø–æ –∫–∞—Ç–µ–≥–æ—Ä–∏—è–º
func registerWBContentTools(tr *toolRegistrar, wbClient wb.Client, cfg config.AppConfig) error {
    tools := []struct {
        name string
        new  func() (tools.Tool, error)
    }{
        {
            "searchwbproducts",
            func() (tools.Tool, error) {
                toolCfg, _ := tr.getToolCfg("searchwbproducts")
                return toolsstd.NewWbProductSearchTool(wbClient, toolCfg, cfg.WB), nil
            },
        },
        {
            "getwbparentcategories",
            func() (tools.Tool, error) {
                toolCfg, _ := tr.getToolCfg("getwbparentcategories")
                return toolsstd.NewWbParentCategoriesTool(wbClient, toolCfg, cfg.WB), nil
            },
        },
        {
            "getwbsubjects",
            func() (tools.Tool, error) {
                toolCfg, _ := tr.getToolCfg("getwbsubjects")
                return toolsstd.NewWbSubjectsTool(wbClient, toolCfg, cfg.WB), nil
            },
        },
        {
            "pingwbapi",
            func() (tools.Tool, error) {
                toolCfg, _ := tr.getToolCfg("pingwbapi")
                return toolsstd.NewWbPingTool(wbClient, toolCfg, cfg.WB), nil
            },
        },
    }
    
    for _, t := range tools {
        toolCfg, exists := tr.getToolCfg(t.name)
        if !exists || !toolCfg.Enabled {
            continue
        }
        
        tool, err := t.new()
        if err != nil {
            return fmt.Errorf("failed to create %s tool: %w", t.name, err)
        }
        
        if err := tr.register(t.name, tool); err != nil {
            return err
        }
    }
    
    return nil
}

func registerWBFeedbackTools(tr *toolRegistrar, wbClient wb.Client) error {
    tools := []struct {
        name string
        new  func() (tools.Tool, error)
    }{
        {
            "getwbfeedbacks",
            func() (tools.Tool, error) {
                toolCfg, _ := tr.getToolCfg("getwbfeedbacks")
                return toolsstd.NewWbFeedbacksTool(wbClient, toolCfg), nil
            },
        },
        {
            "getwbquestions",
            func() (tools.Tool, error) {
                toolCfg, _ := tr.getToolCfg("getwbquestions")
                return toolsstd.NewWbQuestionsTool(wbClient, toolCfg), nil
            },
        },
        // ... more tools in same pattern ...
    }
    
    for _, t := range tools {
        toolCfg, exists := tr.getToolCfg(t.name)
        if !exists || !toolCfg.Enabled {
            continue
        }
        
        tool, err := t.new()
        if err != nil {
            return fmt.Errorf("failed to create %s tool: %w", t.name, err)
        }
        
        if err := tr.register(t.name, tool); err != nil {
            return err
        }
    }
    
    return nil
}

func registerS3Tools(tr *toolRegistrar, state state.CoreState, cfg config.AppConfig) error {
    storage := state.GetStorage()
    if storage == nil {
        return nil  // S3 not configured
    }
    
    tools := []struct {
        name string
        new  func() (tools.Tool, error)
    }{
        {
            "lists3files",
            func() (tools.Tool, error) {
                toolCfg, _ := tr.getToolCfg("lists3files")
                return toolsstd.NewS3ListTool(storage), nil
            },
        },
        {
            "reads3object",
            func() (tools.Tool, error) {
                toolCfg, _ := tr.getToolCfg("reads3object")
                return toolsstd.NewS3ReadTool(storage), nil
            },
        },
        // ... more S3 tools ...
    }
    
    for _, t := range tools {
        toolCfg, exists := tr.getToolCfg(t.name)
        if !exists || !toolCfg.Enabled {
            continue
        }
        
        tool, err := t.new()
        if err != nil {
            return fmt.Errorf("failed to create %s tool: %w", t.name, err)
        }
        
        if err := tr.register(t.name, tool); err != nil {
            return err
        }
    }
    
    return nil
}

func registerDictionaryTools(tr *toolRegistrar, state state.CoreState) error {
    dicts := state.GetDictionaries()
    if dicts == nil {
        return nil  // Dictionaries not loaded
    }
    
    tools := []struct {
        name string
        new  func() (tools.Tool, error)
    }{
        {
            "wbcolors",
            func() (tools.Tool, error) {
                toolCfg, _ := tr.getToolCfg("wbcolors")
                return toolsstd.NewWbColorsTool(dicts, toolCfg), nil
            },
        },
        {
            "wbcountries",
            func() (tools.Tool, error) {
                toolCfg, _ := tr.getToolCfg("wbcountries")
                return toolsstd.NewWbCountriesTool(dicts, toolCfg), nil
            },
        },
        // ... more dictionary tools ...
    }
    
    for _, t := range tools {
        toolCfg, exists := tr.getToolCfg(t.name)
        if !exists || !toolCfg.Enabled {
            continue
        }
        
        tool, err := t.new()
        if err != nil {
            return fmt.Errorf("failed to create %s tool: %w", t.name, err)
        }
        
        if err := tr.register(t.name, tool); err != nil {
            return err
        }
    }
    
    return nil
}

// ‚úÖ NEW: –ì–ª–∞–≤–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è SetupTools - —Ç–µ–ø–µ—Ä—å –∫–æ–º–ø–∞–∫—Ç–Ω–∞ –∏ –ø–æ–Ω—è—Ç–Ω–∞
func SetupTools(state state.CoreState, wbClient wb.Client, visionLLM llm.Provider, cfg config.AppConfig) error {
    registry := state.GetToolsRegistry()
    
    getToolCfg := func(name string) (config.ToolConfig, bool) {
        tc, exists := cfg.Tools[name]
        return tc, exists
    }
    
    tr := &toolRegistrar{
        registry:   registry,
        getToolCfg: getToolCfg,
    }
    
    // –†–µ–≥–∏—Å—Ç—Ä–∏—Ä—É–µ–º –∫–∞–∂–¥—É—é –≥—Ä—É–ø–ø—É –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤
    if err := registerWBContentTools(tr, wbClient, cfg); err != nil {
        return err
    }
    
    if err := registerWBFeedbackTools(tr, wbClient); err != nil {
        return err
    }
    
    if err := registerS3Tools(tr, state, cfg); err != nil {
        return err
    }
    
    if err := registerDictionaryTools(tr, state); err != nil {
        return err
    }
    
    // Vision tools —Ç—Ä–µ–±—É—é—Ç –æ—Ç–¥–µ–ª—å–Ω–æ–π –æ–±—Ä–∞–±–æ—Ç–∫–∏
    if err := registerVisionTools(tr, state, visionLLM, cfg); err != nil {
        return err
    }
    
    return nil
}

// ‚úÖ BONUS: –¢–µ–ø–µ—Ä—å –ª–µ–≥–∫–æ –¥–æ–±–∞–≤–ª—è—Ç—å –Ω–æ–≤—ã–µ –≥—Ä—É–ø–ø—ã –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–æ–≤:
// func registerMyCustomTools(tr *toolRegistrar, myClient MyAPI) error {
//     // Same pattern as above
// }
// 
// –ò –≤ SetupTools –ø—Ä–æ—Å—Ç–æ –¥–æ–±–∞–≤–∏—Ç—å:
// if err := registerMyCustomTools(tr, myClient); err != nil {
//     return err
// }
–ö–ª—é—á–µ–≤–æ–µ –∏–∑–º–µ–Ω–µ–Ω–∏–µ:

go
// ‚ùå –ë–´–õ–û:
func SetupTools(...) error {
    // 200 —Å—Ç—Ä–æ–∫ —Å 80+ –ø–æ–≤—Ç–æ—Ä—è—é—â–∏–º—Å—è –∫–æ–¥–æ–º
    if toolCfg, exists := getToolCfg("tool1"); exists && toolCfg.Enabled {
        register("tool1", NewTool1(...))
    }
    if toolCfg, exists := getToolCfg("tool2"); exists && toolCfg.Enabled {
        register("tool2", NewTool2(...))
    }
    // ... and so on
}

// ‚úÖ –°–¢–ê–õ–û:
func registerToolGroup(tr *toolRegistrar, tools []toolDef) error {
    for _, t := range tools {
        if toolCfg, exists := tr.getToolCfg(t.name); exists && toolCfg.Enabled {
            tool, _ := t.new()
            tr.register(t.name, tool)
        }
    }
    return nil
}

func SetupTools(...) error {
    registerWBContentTools(tr, wbClient, cfg)
    registerS3Tools(tr, state, cfg)
    registerDictionaryTools(tr, state)
    return nil
}
–ü—Ä–µ–∏–º—É—â–µ—Å—Ç–≤–∞:

–ù–∞–º–Ω–æ–≥–æ –ø—Ä–æ—â–µ –¥–æ–±–∞–≤–ª—è—Ç—å –Ω–æ–≤—ã–µ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç—ã

–ö–∞–∂–¥–∞—è –≥—Ä—É–ø–ø–∞ –≤ –æ—Ç–¥–µ–ª—å–Ω–æ–π —Ñ—É–Ω–∫—Ü–∏–∏

–õ–µ–≥—á–µ —Ç–µ—Å—Ç–∏—Ä–æ–≤–∞—Ç—å

–í–∏–¥–Ω–æ –ª–æ–≥–∏–∫—É —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è

üìä –†–ï–ó–Æ–ú–ï –ò–°–ü–†–ê–í–õ–ï–ù–ò–ô
#	Fix	Priority	Effort	Impact
1	HTTP Connection Leak	üî¥ HIGH	30 min	Prevents OOM
2	Race Condition	üî¥ HIGH	15 min	Prevents panic
3	Memory Leak	üî¥ HIGH	2h	Prevents OOM
4	Tool Timeout	üî¥ HIGH	1h	Prevents hang
5	Graceful Shutdown	üî¥ HIGH	1h	Prevents data loss
6	Tools Refactoring	üü° MEDIUM	3h	Code quality
