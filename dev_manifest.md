# Незыблемые правила разработки

## Правила для разработчиков

0. Правило переиспользования кода фреймворка
- любая разработка в рамках кодовой базы должна сначала использовать то, что разработано,но если существующее решение мешает развитию - его можно заменить (рефакторинг)

1. Правило интерфейса инструментов
type Tool interface {
    Definition() ToolDefinition
    Execute(ctx context.Context, argsJSON string) (string, error)
}
Никогда не изменять этот интерфейс. Все инструменты должны реализовывать только этот контракт. "Raw In, String Out" - принцип остается незыблемым.

2. Правило конфигурации
Все настройки должны быть в единственном YAML с поддержкой ENV-переменных. Никакого хардкода в коде. Структура AppConfig может расширяться, но существующие поля не меняются. yaml конфиг лежит рядом с исполняемым файлом каждой утилиты

3. Правило реестра инструментов
Все инструменты регистрируются через Registry.Register(). Никаких прямых вызовов инструментов в обход реестра.

4. Правило абстракции LLM
Работа с AI-моделями только через интерфейс Provider. Никаких прямых вызовов API конкретных провайдеров в бизнес-логике.

5. Правило состояния приложения
Глобальное состояние только через GlobalState с thread-safe доступом. Никаких глобальных переменных.

6. Правило структуры пакетов
pkg/ - только библиотечный код, готовый к переиспользованию
internal/ - внутренняя логика приложения
cmd/ - точка входа, только инициализация и оркестрация
7. Правило обработки ошибок
Все ошибки должны возвращаться вверх по стеку вызовов. Никаких panic() в бизнес-логике. Фреймворк должен обеспечивать resilience против галлюцинаций LLM.

8. Правило расширения функциональности
Новые возможности добавляются только через:

Новые инструменты в pkg/tools/std/ или пользовательские пакеты
Новые адаптеры LLM в pkg/llm/
Расширение конфигурации возможно через breaking changes но с уведомлением пользователя

9. Правило тестирования
Каждый инструмент должен иметь возможность мокирования зависимостей для юнит-тестов. Никаких прямых HTTP-вызовов без возможности абстрагирования. Но! никаких тестов изначально не пишем, вместо тестов готовим утилиту в /examples для проверки функционала. конфиг, промпты, логи - всё это должно лежать рядом с утилитой. запускается утилита всегда из своей папки

10. Правило документации
Все публичные API должны иметь godoc-комментарии. Изменения в интерфейсах должны сопровождаться обновлением примеров использования.

11. Правило распространения контекста и отмены
Все долгосрочные операции должны принимать и корректно обрабатывать context.Context. Контекст должен распространяться через все слои.

**Требования**:
- Все методы Tool.Execute() должны уважать отмену контекста
- Вызовы LLM должны передавать контекст через все слои
- HTTP клиенты должны использовать контекст для запросов
- Фоновые горутины должны наследовать родительский контекст
- Использовать select для проверки контекста в циклах

**Пример**:
```go
// ✅ ХОРОШО: Распространение контекста
func (t *MyTool) Execute(ctx context.Context, argsJSON string) (string, error) {
    // Передаем контекст во все вызовы
    result, err := t.client.DoSomething(ctx, ...)
    if err != nil {
        return "", fmt.Errorf("operation failed: %w", err)
    }
    return result, nil
}

// ❌ ПЛОХО: Игнорирование контекста
func (t *MyTool) Execute(ctx context.Context, argsJSON string) (string, error) {
    // Используем context.Background() - теряем отмену
    result, err := t.client.DoSomething(context.Background(), ...)
    return result, err
}

12. Правило безопасности и управления секретами
Никогда не хардкодить секреты. Использовать переменные окружения или управление секретами. Редактирование логов для чувствительных данных. Валидировать все входные данные.

**Требования**:
- Все секреты в config.yaml должны использовать синтаксис ${VAR}
- Никогда не коммитить секреты в git (добавить в .gitignore)
- Валидировать что секреты не являются дефолтными/шаблонными значениями
- Редактировать чувствительные данные в логах (токены, пароли, PII)
- Использовать HTTPS для всех внешних API вызовов
- Валидировать и санитизировать все пользовательские входы

**Пример**:
```go
// ✅ ХОРОШО: Переменные окружения для секретов
type Config struct {
    APIKey string `yaml:"api_key"` // Загружается из ${API_KEY}
}

// ✅ ХОРОШО: Валидация секретов
func (c *Config) Validate() error {
    if c.APIKey == "" || c.APIKey == "${API_KEY}" {
        return errors.New("API_KEY environment variable not set")
    }
    
    if len(c.APIKey) < 32 {
        return errors.New("API_KEY appears invalid (too short)")
    }
    
    return nil
}

// ✅ ХОРОШО: Редактирование логов
func (t *MyTool) Execute(ctx context.Context, argsJSON string) (string, error) {
    var args struct {
        Token string `json:"token"`
        Data  string `json:"data"`
    }
    json.Unmarshal([]byte(argsJSON), &args)
    
    // Лог с редактированием
    utils.Info("Processing request",
        "token", redactToken(args.Token), // "abc...xyz"
        "data_length", len(args.Data),
    )
    
    return t.process(ctx, args)
}

func redactToken(token string) string {
    if len(token) <= 8 {
        return "***"
    }
    return token[:4] + "..." + token[len(token)-4:]
}
```

13. Правило локализации ресурсов приложений
Любое приложение в /cmd должно быть автономным и хранить свои ресурсы (yaml конфиги, логи и prompts) рядом с собой:

- **Промпты**: по умолчанию в {app_dir}/prompts/ (плоская структура без вложенных папок)
- **Конфиг**: по умолчанию {app_dir}/config.yaml (ищется рядом с исполняемым файлом)
- **Логи**: по умолчанию {app_dir}/logs/ (или stdout для CLI-утилит)

Каждое приложение в /cmd должно реализовывать ConfigPathFinder, который ищет config.yaml только в своей директории, и если это не так, то падает.

## Особые акценты
Особенно хочу выделить несколько пунктов, почему этот манифест так хорош:

"Raw In, String Out" (Правило 1): Это лучшее решение для LLM-инструментов. Попытка сделать типизированные аргументы на уровне интерфейса привела бы к аду с interface{} и рефлексией внутри ядра. А так — каждый инструмент сам знает, как распарсить свой JSON. Это делает систему бесконечно гибкой.

Реестр (Правило 3): Это превращает Poncho из простого скрипта в модульную систему. Можно собрать бинарник с одним набором тулов для админов, и с другим — для пользователей, просто изменив main.go, не трогая ядро.

Абстракция LLM (Правило 4): Критически важно. Сегодня моден OpenAI, завтра DeepSeek, послезавтра локальная Llama. Интерфейс Provider гарантирует, что фреймворк переживет смену хайпа.

Обработка ошибок и Resilience (Правило 7): Для AI-агентов это важнее, чем для веба. Модель будет ошибаться, будет выдавать битый JSON. Отсутствие паники и корректный возврат ошибки — единственный способ сделать стабильного робота.

Локализация ресурсов (Правило 13): Это превращает каждую утилиту в /cmd в самодостаточный артефакт, который можно скопировать в любую директорию и запускать независимо от основного проекта. Нет путаницы "где лежит конфиг?", нет зависимости от корня проекта. CLI-утилита должна работать как любой Linux tool — всё своё ношу с собой.
