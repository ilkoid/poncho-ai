# Незыблемые правила дальнейшей разработки

## Правила для разработчиков

0. Правило переиспользования кода фреймворка
- любая разработка в рамках кодовой базы должна сначала использовать то, что разработано. И только если нужного функционала нет, предлагать его разработать. 
- Это касается и /cmd и /internal и /pkg 

1. Правило интерфейса инструментов
type Tool interface {
    Definition() ToolDefinition
    Execute(ctx context.Context, argsJSON string) (string, error)
}
Никогда не изменять этот интерфейс. Все инструменты должны реализовывать только этот контракт. "Raw In, String Out" - принцип остается незыблемым.

2. Правило конфигурации
Все настройки должны быть в YAML с поддержкой ENV-переменных. Никакого хардкода в коде. Структура AppConfig может расширяться, но существующие поля не меняются.

3. Правило реестра инструментов
Все инструменты регистрируются через Registry.Register(). Никаких прямых вызовов инструментов в обход реестра.

4. Правило абстракции LLM
Работа с AI-моделями только через интерфейс Provider. Никаких прямых вызовов API конкретных провайдеров в бизнес-логике.

5. Правило состояния приложения
Глобальное состояние только через GlobalState с thread-safe доступом. Никаких глобальных переменных.

6. Правило структуры пакетов
pkg/ - только библиотечный код, готовый к переиспользованию
internal/ - внутренняя логика приложения
cmd/ - точка входа, только инициализация и оркестрация
7. Правило обработки ошибок
Все ошибки должны возвращаться вверх по стеку вызовов. Никаких panic() в бизнес-логике. Фреймворк должен обеспечивать resilience против галлюцинаций LLM.

8. Правило расширения функциональности
Новые возможности добавляются только через:

Новые инструменты в pkg/tools/std/ или пользовательские пакеты
Новые адаптеры LLM в pkg/llm/
Расширение конфигурации без breaking changes
9. Правило тестирования
Каждый инструмент должен иметь возможность мокирования зависимостей для юнит-тестов. Никаких прямых HTTP-вызовов без возможности абстрагирования. Но! никаких тестов изначально не пишем, вместо тестов готовим утилиту в /cmd для проверки функционала 

10. Правило документации
Все публичные API должны иметь godoc-комментарии. Изменения в интерфейсах должны сопровождаться обновлением примеров использования.

11. Правило локализации ресурсов приложений
Любое приложение в /cmd должно быть автономным и хранить свои ресурсы рядом с собой:

- **Промпты**: по умолчанию в {app_dir}/prompts/ (плоская структура без вложенных папок)
- **Конфиг**: по умолчанию {app_dir}/config.yaml (ищется рядом с исполняемым файлом)
- **Логи**: по умолчанию {app_dir}/logs/ (или stdout для CLI-утилит)

Каждое приложение в /cmd должно реализовывать ConfigPathFinder, который ищет config.yaml сначала в своей директории, и только потом использует fallback (текущая директория или путь к проекту).

## Особые акценты
Особенно хочу выделить несколько пунктов, почему этот манифест так хорош:

"Raw In, String Out" (Правило 1): Это лучшее решение для LLM-инструментов. Попытка сделать типизированные аргументы на уровне интерфейса привела бы к аду с interface{} и рефлексией внутри ядра. А так — каждый инструмент сам знает, как распарсить свой JSON. Это делает систему бесконечно гибкой.

Реестр (Правило 3): Это превращает Poncho из простого скрипта в модульную систему. Можно собрать бинарник с одним набором тулов для админов, и с другим — для пользователей, просто изменив main.go, не трогая ядро.

Абстракция LLM (Правило 4): Критически важно. Сегодня моден OpenAI, завтра DeepSeek, послезавтра локальная Llama. Интерфейс Provider гарантирует, что фреймворк переживет смену хайпа.

Обработка ошибок и Resilience (Правило 7): Для AI-агентов это важнее, чем для веба. Модель будет ошибаться, будет выдавать битый JSON. Отсутствие паники и корректный возврат ошибки — единственный способ сделать стабильного робота.

Локализация ресурсов (Правило 11): Это превращает каждую утилиту в /cmd в самодостаточный артефакт, который можно скопировать в любую директорию и запускать независимо от основного проекта. Нет путаницы "где лежит конфиг?", нет зависимости от корня проекта. CLI-утилита должна работать как любой Linux tool — всё своё ношу с собой.

## Заключение
Основная сила фреймворка в том, что он следует принципу "Convention over Configuration" - разработчик инструментов следует простым правилам, а фреймворк берет на себя всю рутину промпт-инжиниринга, валидации и оркестрации.


