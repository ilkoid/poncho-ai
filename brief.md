# Poncho AI: Комплексный анализ подходов и архитектуры проекта

## 1. Назначение и функциональность проекта

Poncho AI — это LLM-agnostic, Tool-centric framework на Go. Он предоставляет структуру для создания агентов, беря на себя рутину (промпт-инжиниринг, JSON-валидацию, историю), и оставляет разработчику только реализацию чистой бизнес-логики в виде изолированных инструментов.

Poncho AI — это многофункциональная AI-платформа, предназначенная для автоматизации процессов работы с Wildberries и Ozon (крупные российские маркетплейс-платформы). Проект объединяет в себе возможности обработки изображений, работы с облачным хранилищем S3, интеграцию с различными AI-моделями и предоставляет инструменты для управления товарными карточками, например, подготовкой их описания с помощью PLM на основе входящих данных производственного, маркетингового и e-commers характера. 

Основные функциональные возможности:
- **AI-ассистент** с TUI-интерфейсом на основе Bubble Tea
- **Загрузка файлов** из S3 хранилища по настраиваемым правилам
- **Интеграция с Wildberries API** для работы с каталогами, категориями товаров и справочниками
- **Мультимодальная обработка** изображений и текста через различные AI-провайдеры
- **Система инструментов (Tools)** для расширения функциональности LLM
- **Управление промптами** с шаблонизацией и рендерингом

## 2. Основные компоненты и их взаимосвязи

### Архитектурные слои:

#### **Прикладной слой (cmd/)**
- `cmd/poncho/` — основное приложение с TUI-интерфейсом
- `cmd/simple-chat/` — простое TUI приложение для чата с LLM
- `cmd/simple-llm-util/` — CLI-утилита для прямого взаимодействия с LLM
- `cmd/list-bucket/` — утилита для инспекции S3 бакета
- `cmd/tool-usage-example/` — пример использования AI-агента с инструментами

#### **Внутренняя логика (internal/)**
- `internal/app/state.go` — глобальное состояние приложения с thread-safe доступом
- `internal/app/commands.go` — реестр команд для управления через TUI
- `internal/ui/` — компоненты пользовательского интерфейса (model, view, update, styles)

#### **Библиотечные пакеты (pkg/)**
- `pkg/config/` — управление конфигурацией с поддержкой ENV-переменных
- `pkg/llm/` — абстракция над AI-провайдерами с OpenAI-совместимым адаптером
- `pkg/factory/` — фабрика для создания LLM-провайдеров
- `pkg/s3storage/` — клиент для работы с S3-совместимым хранилищем
- `pkg/wb/` — клиент для Wildberries Content API
- `pkg/tools/` — реестр инструментов для расширения функциональности
- `pkg/classifier/` — движок классификации файлов
- `pkg/prompt/` — система управления промптами с шаблонизацией
- `pkg/todo/` — менеджер задач для планирования действий агента

### Взаимосвязи компонентов:

```
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│   CLI/TUI Apps  │───▶│  Global State    │───▶│  Config Loader  │
└─────────────────┘    └──────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  UI Components  │◀───│ Command Registry │───▶│  Tool Registry  │
└─────────────────┘    └──────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  Todo Manager   │◀───│   File Classifier│───▶│  WB API Client  │
└─────────────────┘    └──────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  S3 Storage     │◀───│  Prompt Engine   │───▶│  AI Tools       │
└─────────────────┘    └──────────────────┘    └─────────────────┘
         │                       │                       │
         ▼                       ▼                       ▼
┌─────────────────┐    ┌──────────────────┐    ┌─────────────────┐
│  LLM Providers  │◀───│  Context Builder │───▶│  Planner Tools  │
└─────────────────┘    └──────────────────┘    └─────────────────┘
```

## 3. Архитектурный подход и его уникальные особенности

### **Гибридная архитектура с доминированием TUI**

Poncho AI использует **TUI-first подход** на основе фреймворка Bubble Tea, что является нетипичным решением для AI-платформ. Этот подход обеспечивает:

- **Высокую производительность** без накладных расходов веб-интерфейса
- **Эффективное использование ресурсов** при работе с большими объемами данных
- **Удобство для разработчиков** и технических специалистов
- **Быструю навигацию** и управление через клавиатурные сокращения

### **Модульная плагинная архитектура**

Ключевая особенность — **система инструментов (Tools)**, которая позволяет:

- **Расширять функциональность** без изменения основного кода
- **Интегрировать внешние API** через унифицированный интерфейс
- **Создавать AI-агентов** с возможностью вызова функций
- **Динамически регистрировать** новые инструменты в реестре

### **Абстракция над AI-провайдерами**

Архитектура обеспечивает **универсальный доступ** к различным AI-моделям:

- **OpenAI-совместимый адаптер** покрывает 99% современных API
- **Фабрика провайдеров** для динамического создания клиентов
- **Унифицированный формат запросов** и ответов
- **Поддержка мультимодальности** (текст + изображения)

### **Конфигурируемая классификация файлов**

**Движок классификации** с настраиваемыми правилами позволяет:

- **Гибко настраивать** правила классификации через YAML
- **Использовать glob-паттерны** для фильтрации файлов
- **Валидировать обязательные** типы файлов
- **Автоматически организовывать** файлы по категориям

### **Система управления задачами (Todo Manager)**

**Интегрированный менеджер задач** обеспечивает:

- **Планирование действий** агента через инструменты `plan_*`
- **Thread-safe управление** задачами с мьютексами
- **Контекстную инъекцию** - план виден AI без вызова инструментов
- **Статусы задач**: PENDING, DONE, FAILED с метаданными

### **Реестр команд (Command Registry)**

**Расширяемая система команд** для TUI:

- **Динамическая регистрация** обработчиков команд
- **Асинхронное выполнение** через tea.Cmd
- **Встроенные команды** для управления Todo (`todo`, `t`)
- **Расширяемость** для добавления новых команд

## 4. Ключевые паттерны и архитектурные решения

### **The Elm Architecture (TEA - Model-View-Update)**
Используется в UI-компонентах:
- **Model** — состояние приложения
- **View** — рендеринг интерфейса
- **Update** — обработка событий и команд
- **Cmd** — асинхронные операции

### **Factory Pattern**
Применяется для создания LLM-провайдеров:
```go
func NewLLMProvider(cfg config.ModelDef) (llm.Provider, error)
```

### **Registry Pattern**
Используется для управления инструментами:
```go
type Registry struct {
    mu    sync.RWMutex
    tools map[string]Tool
}
```

### **Strategy Pattern**
Реализован в классификаторе файлов:
- Различные стратегии сопоставления паттернов
- Гибкая система правил классификации

### **Command Pattern**
Используется в реестре команд:
- Инкапсуляция действий в объекты CommandHandler
- Асинхронное выполнение через tea.Cmd
- Отделение отправителя команды от исполнителя

### **Context Injection Pattern**
Применяется в менеджере задач:
- Автоматическая инъекция контекста плана в системные промпты
- Экономия токенов за счет избежания вызовов инструментов
- Постоянная видимость текущего плана для AI

### **Adapter Pattern**
OpenAI-адаптер обеспечивает совместимость с различными AI API:
```go
type Client struct {
    apiKey  string
    baseURL string
    http    *http.Client
}
```

### **Template Method Pattern**
Система промптов с шаблонизацией:
```go
func (pf *PromptFile) RenderMessages(data interface{}) ([]Message, error)
```

### **Rate Limiting Pattern**
В WB API клиенте реализовано ограничение запросов:
```go
limiter: rate.NewLimiter(r, BurstLimit)
```

## 5. Управление конфигурацией и зависимостями

### **Централизованная конфигурация**

Конфигурация управляется через `pkg/config/` с поддержкой:
- **YAML-формат** для человекочитаемости
- **ENV-переменные** с синтаксисом `${VAR}`
- **Валидация** обязательных полей
- **Типизация** всех конфигурационных параметров

Структура конфигурации:
```yaml
models:          # Настройки AI-моделей
tools:           # Конфигурация инструментов
s3:              # Параметры S3-хранилища
image_processing: # Настройки обработки изображений
app:             # Общие настройки приложения
file_rules:      # Правила классификации файлов
wb:              # Настройки Wildberries API
```

### **Управление зависимостями**

**Go Modules** с четкой структурой зависимостей:
- **Основные зависимости**: Bubble Tea (TUI), MinIO (S3), YAML, OpenAI SDK
- **AI-интеграция**: github.com/sashabaranov/go-openai v1.41.2
- **Rate limiting**: golang.org/x/time/rate
- **Валидация**: встроенные средства Go

### **Зависимости по слоям архитектуры:**

1. **UI слой**: github.com/charmbracelet/bubbletea v1.3.10, github.com/charmbracelet/lipgloss v1.1.0
2. **Хранилище**: github.com/minio/minio-go/v7 v7.0.97
3. **Конфигурация**: gopkg.in/yaml.v3 v3.0.1
4. **AI интеграция**: github.com/sashabaranov/go-openai v1.41.2
5. **Rate limiting**: golang.org/x/time/rate v0.14.0
6. **Утилиты**: github.com/nfnt/resize (обработка изображений)

### **Уникальные особенности управления зависимостями:**

- **Минималистичный подход** — использование стандартной библиотеки там, где возможно
- **OpenAI-совместимость** — один адаптер для множества провайдеров (ZAI, DeepSeek, OpenAI)
- **Легковесные клиенты** — отказ от тяжелых SDK в пользу простых HTTP-клиентов
- **Модульная структура** — четкое разделение зависимостей по пакетам
- **Версионирование** — фиксация версий для стабильности сборок

## Правила для разработки
Poncho AI - фреймворк, архитектурная задача которого не просто  построить простого бота, а платформу, в которую другие разработчики (или я сам в будущем) будут "втыкать" новые инструменты и логику, не переписывая ядро.

Вот архитектурная выжимка именно с точки зрения Framework Design, основанная на основных идеях.

### Poncho AI Framework: Architectural Design Principles

#### 1. Абстракция Инструментов (Tool Definition Interface)
Фреймворк не должен знать жестко о конкретных инструментах (типа Wildberries). Он должен уметь работать с любым инструментом, который соответствует контракту.

Принцип: ToolDef (Definition) как универсальный контракт.

Реализация:

Фреймворк ожидает структуру, содержащую метаданные (Name, Description) и схему аргументов.

Инверсия управления: Пользователь фреймворка регистрирует инструменты, а Фреймворк сам решает, как презентовать их LLM (генерирует системный промпт) и как парсить ответ.

#### 2. Динамическая Генерация Контекста (Dynamic Prompt Engineering)
Одна из задач фреймворка — скрыть от разработчика сложность формирования промптов.

Логика: Ядро фреймворка (BuildAgentContext) объединяет:
- Системный промпт
- "Рабочую память" (результаты анализа файлов)
- Контекст плана (Todo Manager)
- Историю диалога

Автоматизация: Фреймворк сам итерируется по списку инструментов и собирает описание API для LLM.

Почему это важно: Разработчику инструмента не нужно лезть в системный промпт и писать "У тебя есть инструмент X...". Он просто регистрирует структуру, а фреймворк обновляет "инструкцию" для AI на лету.

#### 3. Протокол Взаимодействия (Framework-Level Protocol)
Фреймворк диктует жесткий протокол общения с LLM, чтобы гарантировать предсказуемость.

JSON-RPC Style: Фреймворк навязывает модели формат ответа {"tool": "name", "args": ...}.

Middleware Очистки: Слой санитайзеров для ответов LLM.

Задача: Входящий "сырой" ответ от LLM проходит через слой очистки, прежде чем попасть в роутер исполнения. Это защищает бизнес-логику от галлюцинаций модели (markdown-оберток, лишнего текста).

#### 4. Модульность и Структура Пакетов
Фреймворк предполагает наличие "Стандартной библиотеки":

pkg/tools/std: Встроенные инструменты:
- S3 инструменты (загрузка, обработка изображений)
- Wildberries инструменты (работа с каталогами, справочниками)
- Planner инструменты (управление задачами агента)

User Space: Пользователь фреймворка может создавать свои пакеты с инструментами, аналогичные std, и просто импортировать их.

Изоляция: Код инструмента (бизнес-логика) полностью отделен от кода агента (LLM loops).

#### 5. Обработка ошибок и валидация (Resilience)
Фреймворк берет на себя ответственность за "глупые" ошибки модели.

Если модель прислала битый JSON — фреймворк перехватывает ошибку и возвращает ее наверх по стеку вызовов.

Thread Safety: Все компоненты состояния (GlobalState, Todo Manager, Registry) защищены мьютексами для безопасной работы в конкурентной среде.

Retry Mechanism: Фреймворк поддерживает повторные попытки при временных ошибках API.

#### 6. Система Управления Задачами (Todo Management)
Фреймворк включает встроенный менеджер задач для планирования действий агента:

Todo Manager Features:
- Thread-safe управление задачами с мьютексами
- Статусы задач: PENDING, DONE, FAILED
- Поддержка метаданных для каждой задачи
- Автоматическая инъекция контекста в промпты

Planner Tools:
- `plan_add_task` - добавление задач
- `plan_mark_done` - отметка выполнения
- `plan_mark_failed` - отметка провала с причиной
- `plan_clear` - очистка плана

#### 7. Реестр Команд (Command Registry)
Расширяемая система команд для TUI интерфейса:

Command Pattern Implementation:
- Динамическая регистрация обработчиков
- Асинхронное выполнение через tea.Cmd
- Встроенные команды для управления Todo
- Расширяемость для пользовательских команд

## Poncho AI Framework: Core Architectural Components

#### 1. Tooling Layer (Уровень Инструментов)
Инструменты — это граждане первого класса. Фреймворк не реализует логику сам, он оркестрирует исполнение.

Контракт Tool (Interface)
Основа расширяемости. Любой код может стать инструментом, если реализует этот интерфейс.

```go
type Tool interface {
    Definition() ToolDefinition             // Метаданные для LLM
    Execute(ctx context.Context, argsJSON string) (string, error) // Изолированная логика
}
```

Registry (Реестр)
Центральная точка доступа.

Pattern: Service Locator / Registry.

Механика: Инструменты регистрируются при старте приложения (tools.Register(...)). При вызове фреймворк ищет инструмент по имени (Get(name)). Это позволяет динамически включать/выключать наборы функций.

#### 2. LLM Abstraction Layer (Слой Абстракции Модели)
Фреймворк изолирует бизнес-логику от конкретного провайдера (ZAI, OpenAI, DeepSeek и т.д.).

Interface: Provider (в pkg/llm).

```go
type Provider interface {
    Generate(ctx context.Context, messages []Message, tools ...any) (Message, error)
}
```

Фреймворк работает с универсальной структурой Message (Role, Content, ToolCalls, Images), а не с проприетарными типами SDK.

Адаптеры: В pkg/llm/openai лежит реализация адаптера, который конвертирует внутренние сообщения Poncho в формат OpenAI API.

Factory Pattern: pkg/factory/llm_factory.go создает провайдеров на основе конфигурации.

#### 3. State Management (Управление Состоянием)
Фреймворк — это Stateful система с thread-safe доступом.

GlobalState: Централизованное хранилище:
- История диалога (History)
- "Рабочая память" (Files с VisionDescription)
- Todo Manager для планирования
- Command Registry для TUI
- Tools Registry для агента

Thread Safety: Все поля, изменяемые в runtime, защищены sync.RWMutex.

Context Building: Метод BuildAgentContext() собирает полный контекст для LLM:
- Системный промпт
- Результаты анализа файлов
- Текущий план действий
- Историю диалога

#### 4. Execution Pipeline (Цикл Исполнения)
Основной цикл работы агента — это конвейер:

Context Construction: Сборка через BuildAgentContext().

Inference: Вызов LLM через Provider.Generate().

Sanitization: Очистка ответа от markdown-оберток.

Routing: Парсинг ToolCalls -> Поиск в ToolsRegistry -> Вызов Execute().

Feedback: Результат выполнения добавляется в историю, замыкая цикл.

#### 5. DX & Configuration (Опыт разработчика)
Config-First: Все настройки вынесены в YAML с поддержкой ENV-переменных.

Простота входа: Чтобы добавить новую функциональность:
- Написать структуру, реализующую Tool
- Зарегистрировать её через registry.Register()
- Всё остальное (промпты, парсинг, HTTP) фреймворк сделает сам

Environment Variables Required:
- ZAI_API_KEY - для AI провайдера
- S3_ACCESS_KEY, S3_SECRET_KEY - для хранилища
- WB_API_KEY - для Wildberries API

## Заключение

Poncho AI представляет собой **зрелую AI-платформу** с уникальным TUI-подходом, модульной архитектурой и высокой степенью настраиваемости. Проект демонстрирует передовые практики Go-разработки, включая четкое разделение ответственности, использование паттернов проектирования и эффективное управление зависимостями.

### Ключевые достижения архитектуры:

1. **Thread-Safe State Management**: Все компоненты состояния защищены мьютексами для безопасной работы в конкурентной среде
2. **Context Injection**: Автоматическая инъекция контекста задач и файлов в промпты экономит токены и улучшает качество ответов
3. **Modular Tool System**: "Raw In, String Out" принцип обеспечивает максимальную гибкость при минимальных зависимостях
4. **Command Registry**: Расширяемая система команд для TUI позволяет легко добавлять новый функционал
5. **Todo Integration**: Встроенный менеджер задач обеспечивает планирование действий агента

### Доступные приложения:

- **Основное TUI приложение** (`cmd/poncho/`) — полнофункциональный интерфейс для работы с агентом
- **Simple Chat** (`cmd/simple-chat/`) — минималистичный чат с LLM для быстрого тестирования
- **CLI утилиты** для специфических задач (инспекция S3, прямые запросы к LLM)
- **Примеры использования** для изучения фреймворка

Архитектура платформы обеспечивает масштабируемость, расширяемость и удобство поддержки, что делает ее отличным примером современной разработки AI-систем на Go.